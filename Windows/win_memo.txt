

■ファイル一覧
dir /b /s > all.txt



■クラッシュダンプを取得

### 1. Windows Error Reporting (WER) を利用する方法

Windowsは、クラッシュ時に自動的にダンプファイルを作成するように設定できます。設定手順は以下の通りです。

1. **レジストリでダンプ設定を行う**  
   1. 「regedit」を管理者権限で実行します。  
   2. 次のキーに移動します:  
      ```
      HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\Windows Error Reporting\LocalDumps
      ```
   3. キーが存在しない場合は、新しく作成してください（右クリック→新規→キー）。  
   4. 以下の値を設定します（新規作成が必要な場合は右クリック→新規→DWORDまたは文字列値）：
      - **DumpFolder (REG_EXPAND_SZ)**  
        → ダンプファイルを保存するフォルダのパス（例: `C:\CrashDumps`）
      - **DumpCount (DWORD)**  
        → 保存するダンプファイルの最大数（例: `10`）
      - **DumpType (DWORD)**  
        → ダンプの種類。  
        - 1：小さいダンプ（最小限の情報）  
        - 2：フルダンプ（詳細な情報）  
        → スタックトレースの解析に役立つため、通常は「2」を設定します。

3. **アプリケーションのクラッシュを再現する**  
   - 設定後、アプリケーションがクラッシュすると、指定したフォルダにダンプファイル（.dmp）が保存されます。

---

### 2. ProcDump ユーティリティを利用する方法

Microsoftが提供する無料のツール「ProcDump」を使うと、特定のプロセスのダンプを簡単に取得できます。

1. **ProcDumpのダウンロード**  
   - [Microsoft Sysinternalsのサイト](https://learn.microsoft.com/ja-jp/sysinternals/downloads/procdump)から「ProcDump」をダウンロードし、適当なフォルダに展開します。

2. **コマンドプロンプトを管理者権限で実行**  
   - 管理者権限でコマンドプロンプトを開き、ProcDumpのあるフォルダに移動します。

3. **クラッシュ時のダンプ取得のコマンド例**  
   - 例えば、プロセス名が「MyApp.exe」の場合、次のように実行します：
     ```
     procdump -ma MyApp.exe C:\CrashDumps\MyApp.dmp
     ```
     - `-ma` は「フルダンプ」を取得するオプションです。
     - ダンプファイルは指定したパスに保存されます。

4. **クラッシュのタイミングに合わせて**  
   - ProcDumpはリアルタイムでプロセスを監視し、例外やクラッシュが発生したときにダンプを取得できます。  
   - 例えば、例外発生時にダンプを取得する場合は、次のようにオプションを追加できます：
     ```
     procdump -ma -e MyApp.exe C:\CrashDumps\MyApp.dmp
     ```
     - `-e` は例外発生時にダンプを取るオプションです。


----------------
Visual Studioを使ってダンプファイルを解析する基本的な手順は以下の通りです。

1. **Visual Studioの起動とダンプファイルの読み込み**  
   - Visual Studioを起動します。  
   - メニューバーから「ファイル」→「開く」→「ファイル…」を選び、対象のダンプファイル（*.dmp）を指定して開きます。  
   - ダンプファイルを読み込むと、どの種類のダンプか（ミニダンプかフルダンプかなど）を聞かれる場合があります。通常は「自動」や「デフォルト」を選んで進めてください。

2. **ダンプサマリーの確認**  
   - ダンプファイルを開くと、まず「ダンプサマリー」が表示されます。ここには、クラッシュの原因となった例外情報やクラッシュ時のプロセス情報が簡単にまとめられています。  
   - ここで異常の概要（例：例外コード、発生場所）が確認できます。

3. **シンボルの設定**  
   - 正しいシンボル情報がないと、コールスタックなどの詳細な解析が難しくなります。  
   - 「ツール」→「オプション」→「デバッグ」→「シンボル」を開き、Microsoft Symbol Server（URL: `https://msdl.microsoft.com/download/symbols`）を追加してください。  
   - これにより、Visual Studioは必要なデバッグ情報を自動的にダウンロードします。

4. **コールスタックの確認**  
   - 「デバッグ」メニューから「ウィンドウ」→「コールスタック」を選んで、クラッシュ時の関数呼び出しの流れを確認します。  
   - ここで、どの関数が呼ばれているか、どこでエラーが発生しているかが分かります。特に、例外コードやエラーメッセージが示す箇所に注目してください。

5. **変数やその他のウィンドウの活用**  
   - 「ローカル」ウィンドウや「自動」ウィンドウを開いて、クラッシュ時の変数の状態を確認することも有用です。  
   - 必要に応じて「ウォッチ」ウィンドウを使い、特定の変数やオブジェクトの内容を詳しく調べてみてください。

6. **解析結果の整理**  
   - 得られた情報を元に、どの部分で問題が発生しているのか、どのような状態でクラッシュが起こったのかを整理します。  
   - この情報をもとに、コードや使用しているコンポーネント側の問題、または設定の不備などを考慮して対策を検討してください。

以上の手順で、Visual Studio内でダンプファイルを読み込み、クラッシュの原因を探ることができます。最初はダンプサマリーとコールスタックの情報から、大まかな原因を把握するのがポイントです。

----------------
ネットに接続できない環境でも、事前にシンボルファイルをダウンロードしておき、Visual Studioで参照することは可能です。以下の手順で進めてみてください。

---

### 1. ネット接続可能なPCでシンボルをダウンロードする

**① デバッグツールの準備**  
Microsoft の「Debugging Tools for Windows」（Windows SDKに含まれています）には、シンボルをダウンロードするためのツール `symchk.exe` があります。  
- もしまだインストールしていなければ、Windows SDK をインストールしてください。

**② シンボルのダウンロードコマンドの実行**  
コマンドプロンプトを管理者権限で開き、以下のようなコマンドを実行します。  
ここでは例として、`C:\MyApp\bin` 内の実行ファイルに関連するシンボルをダウンロードし、`C:\SymbolCache` に保存する場合です。

```bat
symchk /r C:\MyApp\bin /s SRV*C:\SymbolCache*https://msdl.microsoft.com/download/symbols
```

- `/r` はフォルダ内を再帰的に検索するオプションです。  
- `/s` の後には「シンボルサーバー」の指定をしており、`SRV*保存先フォルダ*シンボルサーバーのURL` という形式になります。

**③ ダウンロード完了後**  
指定した `C:\SymbolCache` フォルダに、必要なシンボルファイルが保存されているはずです。

---

### 2. オフラインPCにシンボルファイルを移動する

- ネットに接続できないVisual StudioがあるPCに、上記で作成した `C:\SymbolCache` フォルダ（または任意の保存先フォルダ）をコピーします。

---

### 3. Visual Studioでローカルシンボルフォルダを設定する

**① Visual Studioを起動する**

**② シンボル設定画面を開く**  
- メニューから「ツール」→「オプション」を選択します。  
- 「デバッグ」→「シンボル」をクリックします。

**③ シンボルファイルの場所を追加する**  
- 「シンボルファイル(.pdb)の場所」に、先ほどコピーしたシンボルフォルダのパス（例：`C:\SymbolCache`）を追加します。

**④ 設定を保存する**  
- OKボタンを押して設定を保存します。

---

### 4. ダンプ解析時の確認

- ダンプファイルをVisual Studioで開いて解析を開始します。  
- 出力ウィンドウや「モジュール」ウィンドウで、シンボルが正しく読み込まれているか確認してください。  
  ※ 読み込みが成功していれば、各モジュールの横にシンボルのパスが表示されるはずです。

---

以上の手順で、ネットに接続できない環境でも必要なシンボルファイルを利用してダンプ解析を進めることができます。何か不明な点があれば、遠慮なく質問してください。



-----------------
以下は、VB.NETでP/Invokeを使い、現在のスタック領域の情報を取得するためのサンプルコードです。  
この例では、GCHandleで配列をピン留めし、そのアドレス（現在のスタック上の一部）を基準に、Windows APIの VirtualQuery 関数を呼び出して、MEMORY_BASIC_INFORMATION 構造体にスタック領域の情報を取得します。

```vbnet
Imports System
Imports System.Runtime.InteropServices

Module Module1

    ' VirtualQueryで返される情報を格納する構造体
    <StructLayout(LayoutKind.Sequential)>
    Public Structure MEMORY_BASIC_INFORMATION
        Public BaseAddress As IntPtr         ' この領域の開始アドレス
        Public AllocationBase As IntPtr      ' 仮想メモリ領域の割り当て開始アドレス（スタック全体の先頭）
        Public AllocationProtect As UInteger ' 割り当て時の保護属性
        Public RegionSize As UIntPtr         ' この領域のサイズ（バイト単位）
        Public State As UInteger             ' 領域の状態
        Public Protect As UInteger           ' 現在の保護属性
        Public Type As UInteger              ' 領域の種類
    End Structure

    ' VirtualQuery関数の宣言
    <DllImport("kernel32.dll")>
    Public Function VirtualQuery( _
        ByVal lpAddress As IntPtr, _
        ByRef lpBuffer As MEMORY_BASIC_INFORMATION, _
        ByVal dwLength As UIntPtr) As UIntPtr
    End Function

    Sub Main()
        ' ローカル変数として配列を作成し、ピン留めしてそのアドレスを取得します。
        Dim dummyArray() As Integer = {0}
        Dim handle As GCHandle = GCHandle.Alloc(dummyArray, GCHandleType.Pinned)
        Try
            Dim localAddress As IntPtr = handle.AddrOfPinnedObject()

            Dim mbi As New MEMORY_BASIC_INFORMATION()
            Dim mbiSize As UIntPtr = CType(Marshal.SizeOf(GetType(MEMORY_BASIC_INFORMATION)), UIntPtr)

            ' localAddressが属する仮想メモリ領域の情報を取得
            Dim result As UIntPtr = VirtualQuery(localAddress, mbi, mbiSize)

            If result = UIntPtr.Zero Then
                Console.WriteLine("VirtualQueryの呼び出しに失敗しました。")
            Else
                Console.WriteLine("取得したスタック領域の情報:")
                Console.WriteLine("  BaseAddress     : 0x" & mbi.BaseAddress.ToString("X"))
                Console.WriteLine("  AllocationBase  : 0x" & mbi.AllocationBase.ToString("X"))
                Console.WriteLine("  RegionSize      : " & mbi.RegionSize.ToUInt64() & " バイト")
                Console.WriteLine("  State           : 0x" & mbi.State.ToString("X"))
                Console.WriteLine("  Protect         : 0x" & mbi.Protect.ToString("X"))
                Console.WriteLine("  Type            : 0x" & mbi.Type.ToString("X"))

                ' Windowsではスタックは下方向に成長します。
                ' 通常、AllocationBaseはスタックの「上端」（高アドレス側）、
                ' BaseAddressはスタックの「下端」（低アドレス側）を示します。
                ' 現在のスタック使用量の概算として、AllocationBaseと現在のローカル変数のアドレスとの差を求めることができます。
                Dim remainingStack As ULong = CULng(CType(localAddress, Long) - CType(mbi.BaseAddress, Long))
                Console.WriteLine("現在のローカル変数から下端までの推定残りスタック容量: " & remainingStack & " バイト")
            End If
        Finally
            handle.Free()
        End Try

        Console.WriteLine("終了するには何かキーを押してください...")
        Console.ReadKey()
    End Sub

End Module
```

### コードのポイント

1. **MEMORY_BASIC_INFORMATION構造体**  
   Windows APIの VirtualQuery 関数で返される情報を受け取るための構造体です。  
   ・BaseAddress：現在のメモリ領域の開始アドレス  
   ・AllocationBase：このメモリ領域（スタック全体）の割り当て開始アドレス  
   ・RegionSize：この領域のサイズ（バイト単位）などの情報が含まれます。

2. **GCHandleによるピン留め**  
   VB.NETでは、ローカル変数のアドレスを直接取得することはできません。そのため、簡単な配列を作成し、GCHandle.Allocでピン留めすることで、そのアドレス（スタック上の位置）を取得しています。

3. **VirtualQueryの呼び出し**  
   ピン留めしたアドレスを渡し、そのアドレスが属するメモリ領域（通常、スタック領域）の情報を取得します。

4. **スタックの残り容量の概算**  
   Windowsのスタックは下方向に成長するため、AllocationBase（スタックの上端：高アドレス）とBaseAddress（スタックの下端：低アドレス）の差などから、現在のローカル変数の位置と下限との距離を概算できます。

このコードを実行すると、コンソールにスタック領域の各種情報と、現在のローカル変数位置からの残り容量の概算値が表示されます。  
※なお、取得できる情報はプロセスの仮想メモリの状態によるため、実際の「使用中のスタック容量」や「残り容量」は環境や状況により変動する点に注意してください。





Rust memo

参考：
https://www.tohoho-web.com/ex/rust.html#as
https://tourofrust.com/TOC_ja.html

-----------------------------------------------
■開発環境構築

1.Microsoft C++ Build Toolsのインストール
   https://visualstudio.microsoft.com/ja/visual-cpp-build-tools/
   →C++だけ入れる

2.Rustのインストール
   https://www.rust-lang.org/tools/install
   →インストーラ叩いて、1 + Enter

3.Visual Studio Code（VSCode）のインストール

4;拡張機能「rust-analyzer」のインストール

5;拡張機能「CodeLLDB」のインストール

-----------------------------------------------
■Hello world

1.適当にフォルダを作成してCD

2.以下コマンドを実行
  >cargo new hello

  →src\main.rs
    などが作成される。

3.VSCodeで作成したフォルダを開く

3.F5で実行
  →初回実行時は、launch.jsonがないのでエラーが出る。
    Yes/No/CancelのポップアップでYesを押せば作られる。

-----------------------------------------------
■学習
公式がわかりやすい！
https://doc.rust-jp.rs/book-ja/index.html

-----------------------------------------------
■予約語

as          // 型変換
as          // モジュールの別名
async       // 非同期処理
await       // 非同期処理
break       // ループから抜ける
const       // 変数・定数
continue    // 次のループを続ける
crate       // ルートモジュール
dyn         // トレイトの直接利用
else        // 条件分岐
enum        // 列挙型
extern      // 外部ライブラリ
false       // 真偽値の偽
fn          // 関数
for         // 繰り返し
if          // 条件分岐
impl        // インプリメンテーション
in          // 繰り返し
let         // 変数・定数
loop        // ループ
match       // マッチ ※switchの高機能版
mod         // モジュール定義
move        // クロージャーに所有権を引き渡す
mut         // 変数・定数
pub         // モジュール外公開
ref         // 参照型
return      // 関数の戻り値
Self        // 実装における自分の型
self        // 自オブジェクト
self        // 自モジュール
static      // 静的変数
struct      // 構造体
super       // 親モジュール
trait       // トレイト
true        // 真偽値の真
type        // 型エイリアス
union       // 共用体
unsafe      // 非安全コード
use         // モジュール使用		C#のusingと同じ
where       // 型を強要する
while       // 繰り返し

-----------------------------------------------
■コメント

//ラインコメント

/* 複数行
   コメント */

/// 3連スラッシュはrustdocによるドキュメンテーションに利用されます

-----------------------------------------------
■型

bool            // 真偽値(true/false)
i8              // 符号付き8ビット整数
u8              // 符号無し8ビット整数
i16             // 符号付き16ビット整数
u16             // 符号無し16ビット整数
i32             // 符号付き32ビット整数
u32             // 符号無し32ビット整数
i64             // 符号付き64ビット整数
u64             // 符号無し64ビット整数
i128            // 符号付き128ビット整数
u128            // 符号無し128ビット整数
isize           // ポインタサイズと同じ符号付き整数 (CPUによる。64bitCPUなら64bit)
usize           // ポインタサイズと同じ符号無し整数 (同上)
f32             // 32ビット浮動小数点数
f64             // 64ビット浮動小数点数
char            // 文字(U+0000～U+D7FF, U+E000～U+10FFFF)
str             // 文字列(&strとして使用することが多い)		UTF-8
(type, type, .) // タプル
[type; len]     // 配列
Vec<type>       // ベクタ
&type           // typeへの参照
&mut type       // typeへのミュータブルな参照
&[type]         // type型要素を持つスライス

'				// ライフタイム指定子
'static			// 


-----------------------------------------------
■値

true            // 真偽値の真(bool)
false           // 真偽値の偽(bool)
12345           // 整数
12_345_678      // カンマの代わりに_を使用して読みやすく
12345u32        // u32型の12345
0xfff           // 16進数
0o777           // 8進数
0b11001100      // 2進数
'あ'            // 文字(char)
"..."           // 文字列(&str)
r"..."          // raw文字列
r#"..."#        // ダブルクォートをそのまま使用できる文字列
b'a'            // 1バイト文字(u8)
b"abc"          // バイト配列(&[u8])
br"..."         // rawバイト配列(&[u8])
-----------------------------------------------
■変数・定数(let, mut, const)

let n = 0;      // 変更不可（イミュータブル)変数

let mut n = 0;  // 変更可能な(ミュータブル)変数

const MAX_POINTS: u32 = 100_000;        // 定数

-----------------------------------------------
■型変換(as)

let x: i32 = 123;
let y: i64 = x as i64;

-----------------------------------------------
■演算子(+ - ...)

-expr               // 負数
expr + expr         // 加算
expr - expr         // 減算
expr * expr         // 乗算
expr / expr         // 除算
expr % expr         // 剰余
expr & expr         // 論理積(AND)
expr | expr         // 論理和(OR)
expr ^ expr         // 排他的論理和(XOR)
expr << expr        // ビット左シフト
expr >> expr        // ビット右シフト
var = expr          // 代入
var += expr         // var = var + expr と同義
var -= expr         // var = var - expr と同義
var *= expr         // var = var * expr と同義
var /= expr         // var = var / expr と同義
var %= expr         // var = var % expr と同義
var &= expr         // var = var & expr と同義
var |= expr         // var = var | expr と同義
var ^= expr         // var = var ^ expr と同義
var <<= expr        // var = var << expr と同義
var >>= expr        // var = var >> expr と同義
expr == expr        // 比較：等しい
expr != expr        // 比較：等しくない
expr < expr         // 比較：より大きい
expr <= expr        // 比較：以上
expr > expr         // 比較：より小さい
expr >= expr        // 比較：以下
expr && expr        // かつ(AND)
expr || expr        // または(OR)
!expr               // 否定(NOT)

fn(...) -> type     // 関数の型定義
expr;               // 行の終わり
'label              // ラベル
expr..expr          // 範囲
macro!(...)         // マクロ呼び出し		println!()やpanic!()もマクロ。
macro![...]         // マクロ呼び出し
macro!{...}         // マクロ呼び出し
[type; len]         // 配列


pat => expr
expr?
&expr
&type
*expr
*type
trait + trait
expr , expr
expr.ident
expr..=expr
..expr
variant(..)
expr...expr
ident: expr
ident @
pat | pat

::					// スコープ演算子
::<Type>			// Turbo Fish (ターボフィッシュ)
					// →Generic関数を呼び出すときに必要。


-----------------------------------------------
■構造体(struct)   ※クラスみたいなもの

struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 100, y: 200 };
    println!("{} {}", p.x, p.y);
}

----
..記法

構造体更新記法を使用して、

let user2 = User {
    email: String::from("another@example.com"),
    username: String::from("anotherusername567"),
    ..user1			// 新しいUserインスタンス用の値に新しいemailとusernameをセットしつつ、 
					// 残りの値は、user1変数のフィールド値を使う
};

----
タプル構造体

struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);

----
ユニット様構造体

一切フィールドのない構造体

----
構造体をprintlnするには

#[derive(Debug)]			// キモ
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!("rect1 is {:?}", rect1);		// キモ ({:?})  →{:#?}でも良い。
}

-----
メソッドを追加    ※ようするにpublic method

#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {						// キモ		impl
    fn area(&self) -> u32 {				// キモ		&self
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}

-----
関連関数   ※ようするにpublic static method

impl Rectangle {
    fn square(size: u32) -> Rectangle {				// キモ   selfがないだけ。
        Rectangle { width: size, height: size }
    }
}

呼び出しは::を使う。
let sq = Rectangle::square(3);


-----
複数のimplブロック

分割して書いてもよい。※ようはpartial class

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

------
struct QuitMessage; // ユニット構造体
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // タプル構造体
struct ChangeColorMessage(i32, i32, i32); // タプル構造体




-----------------------------------------------
■列挙型(enum)

enum Color {
    Red,
    Green,
    Blue,
}
let color = Color::Red;

----
データ格納

// 例1
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from("::1"));

// 例2
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

----
メソッド定義

impl Message {
    fn call(&self) {
        // method body would be defined here
        // メソッド本体はここに定義される
    }
}

let m = Message::Write(String::from("hello"));
m.call();

----



-----------------------------------------------
■タプル(tup)

let tup = (10, "20", 30);
println!("{} {} {}", tup.0, tup.1, tup.2);

// 分配
let (x, y, z) = tup;
println!("y={}", y);	// 20




-----------------------------------------------
■配列(array)

let arr = [10, 20, 30];
println!("{} {} {}", arr[0], arr[1], arr[2]);

for v in &arr {
    println!("{}", v);
}

-----------------------------------------------
■ベクタ(vec)

let mut vect = vec![10, 20, 30];
vect.push(40);
println!("{} {} {} {}", vect[0], vect[1], vect[2], vect[3]);

for v in &vect {
    println!("{}", v);
}

-----------------------------------------------
■ハッシュマップ(HashMap)

use std::collections::HashMap;
let mut map = HashMap::new();
map.insert("x", 10);
map.insert("y", 20);
map.insert("z", 30);
println!("{} {} {}", map["x"], map["y"], map["z"]);

for (k, v) in &map {
    println!("{} {}", k, v);
}

-----------------------------------------------
■文字列(&str, String)

let mut name: &str = "Yamada";
name = "Tanaka";


----
生文字列では、r#"で始まり"#で終わる文字列を逐語的に書くことができます。 
これによって、通常の文字列との区別がつかない可能性のある文字をリテラルとして挿入することができます。
(二重引用符やバックスラッシュなど)

fn main() {
    let a: &'static str = r#"
        <div class="advice">
            生文字列は様々な場面で役に立ちます。
        </div>
        "#;
    println!("{}", a);
}
----
スライス

fn main() {
    let a = "hi 🦀";
    println!("{}", a.len());
    let first_word = &a[0..2];
    let second_word = &a[3..7];
    // let half_crab = &a[3..5]; は失敗します。
    // Rust は無効な unicode 文字のスライスを受け付けません。
    println!("{} {}", first_word, second_word);
}

----





-----------------------------------------------
■ヒープ領域(Box)

struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p: Box<Point> = Box::new(Point { x: 100, y: 200 });
    println!("{} {}", p.x, p.y);
}

-----------------------------------------------
■スライス(&var[n..m])

所有権のないデータ型
Stringの一部への不変の参照

let s = String::from("ABCDEFGH");
let s1 = &s[0..3];              // 0番目から3番目の手前までのスライス("ABC")
let s2 = &s[3..6];              // 3番目から6番目の手前までのスライス("DEF")
println!("{} {}", s1, s2);      // => ABC DEF

let a = [10, 20, 30, 40, 50, 60, 70, 80];
let a1 = &a[0..3];              // 0番目から3番目の手前までのスライス[10, 20, 30]
let a2 = &a[3..6];              // 0番目から3番目の手前までのスライス[40, 50, 60]
println!("{:?} {:?}", a1, a2);  // => [10, 20, 30] [40, 50, 60]


-----------------------------------------------
■関数(fn)

fn add(x: i32, y: i32) -> i32 {
    return x + y;
}

// return されない場合は、最後の式が戻り値として返されます。最後のセミコロン ; は記述してはなりません。
fn add(x: i32, y: i32) -> i32 {
    x + y   // セミコロン(;)無し
}





-----------------------------------------------
■クロージャー(|...|{...})

クロージャー は他の言語で言うところの無名関数やラムダ式に似ています。
下記の例では x を受け取り、その二乗を返却するクロージャーを square 変数に代入し、使用しています。

let square = | x: i32 | {
    x * x
};
println!("{}", square(9));



-----------------------------------------------
■条件分岐(if)

if n == 1 {
    println!("One");
} else if n == 2 {
    println!("Two");
} else {
    println!("Other");
}

-----------------------------------------------
■繰り返し(while)

let mut n = 0;
while n < 10 {
    n += 1;
}

-----------------------------------------------
■繰り返し(for)

for i in 0..10 {
    println!("{}", i);
}

-----------------------------------------------
■ループ(loop)

let mut n = 0;
loop {
    n += 1;
    if n == 10 {
        break;
    }
}

----
ラベル付き

fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {}", count);
        let mut remaining = 10;

        loop {
            println!("remaining = {}", remaining);
            if remaining == 9 {
                break;						// 内側のloopを抜ける
            }
            if count == 2 {
                break 'counting_up;			// ラベル付きのloopを抜ける
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {}", count);
}




-----------------------------------------------
■ループ制御(break, continue)

let mut n = 0;
loop {
    n += 1;
    if n == 2 {
        continue;
    }
    if n == 8 {
        break;
    }
    println!("{}", n);
}

-----------------------------------------------
■マッチ(match)

let x = 2;
match x {
    1 => println!("One"),
    2 => println!("Two"),
    3 => println!("Three"),
    _ => println!("More"),		// _はswitch文のdefault同じ
}

-----
if let

let mut count = 0;
match coin {
    // {:?}州のクォーターコイン
    Coin::Quarter(state) => println!("State quarter from {:?}!", state),
    _ => count += 1,
}
は、if letで以下のように書ける。

let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("State quarter from {:?}!", state);
} else {
    count += 1;
}



-----------------------------------------------
■インプリメンテーション(impl)

Rust ではクラスはサポートされていませんが、
impl によって構造体にメソッドを加えることができます。
self は自オブジェクトを示します。

struct Rect { width: u32, height: u32 }

impl Rect {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let r = Rect { width: 200, height: 300 };
    println!("{}", r.area());
}

-----------------------------------------------
■トレイト(trait)

trait は特質の意味で、構造体が実装すべきメソッドを定義します。
他言語の インタフェース(interface) に似ています。
例えば、std::fmt::Display トレイトを実装した構造体は println!() の "{}" で、
std::fmt::Debug トレイトを実装した構造体は "{:?}" で書き出すことが可能です。

struct Rect { width: u32, height: u32 }

trait Printable { fn print(&self); }
impl Printable for Rect {
    fn print(&self) {
        println!("width:{}, height:{}", self.width, self.height)
    }
}

fn main() {
    let r = Rect { width: 200, height: 300 };
    r.print();
}

上記の例では u64 を扱う Rect も用意するには impl Printable for RectU32 { ... } と 
impl Printable for RectU64 { ... } の二つを実装する必要がありますが、
下記の様にして、任意の型を持つ実装を行うことができます。
where はその型が、指定したトレイトを実装している時のみ利用可能であることを示します。

struct Rect<T> { width: T, height: T, }

trait Printable { fn print(&self); }
impl<T> Printable for Rect<T> where T: std::fmt::Display {
    fn print(self: &Rect<T>) {
        println!("{}x{}", self.width, self.height);
    }
}

fn main() {
    let r1: Rect<i32> = Rect{ width: 100, height: 200 };
    let r2: Rect<i64> = Rect{ width: 100, height: 200 };
    r1.print();
    r2.print();
}

-----
トレイト境界






-----------------------------------------------
■イテレータ(Iterator)

struct Counter {
    max: u32,
    count: u32,
}

impl Counter {
    fn new(max: u32) -> Counter {
        Counter { max: max, count: 0 }
    }
}

impl Iterator for Counter {
    type Item = u32;
    fn next(&mut self) -> Option<Self::Item> {
        self.count += 1;
        if self.count < self.max {
            Some(self.count)
        } else {
            None
        }
    }
}

fn main() {
    let counter = Counter::new(10);
    for c in counter {
        println!("{}", c);
    }
}

-----------------------------------------------
■マルチスレッド(thread)

use std::thread;
use std::time::Duration;

fn main() {
    // スレッドを起動する
    // 引数にクロージャー(ラムダ関数)を指定
    let th = thread::spawn(|| {
        for _i in 1..10 {
            println!("A");
            thread::sleep(Duration::from_millis(100));
        }
    });
    th.join().unwrap();
    println!("Finished");
}

スレッドからスレッド外の変数を参照するには、
move によって変数の所有権をスレッドに引き渡すことを明示する必要があります。

fn main() {
    let str = String::from("ABC");
    let th = thread::spawn(move || {    // 所有権を引き渡すことを明示
        for _i in 1..10 {
            println!("{}", str);    // strの所有権を得る
            thread::sleep(Duration::from_millis(100));
        }
    });
    th.join().unwrap();
    println!("Finished");
    // println!("{}", str);     // 所有権移動済のためエラー
}

-----------------------------------------------
■非同期関数(async, await)

async, await を用いて非同期関数を利用することができます。
下記は、Rustの説明書 に記載されているサンプルで、歌を歌いながらダンスができるように書かれているのですが、
どうも、歌い終わってからでないとダンスしないみたいで、もう少し分かりやすいシンプルなサンプルを
提供できる方はお願いします。

use futures::executor::block_on;

struct Song {
    lyric: String,
}

async fn learn_and_sing() {
    let song = learn_song().await;
    sing_song(song).await;
}

async fn learn_song() -> Song {
    let song = Song { lyric: String::from("La la la...") };
    println!("Learned song");
    return song;
}

async fn sing_song(song: Song) {
    println!("{}", song.lyric);
}

async fn dance() {
    println!("Dance");
}

async fn async_main() {
    let f1 = learn_and_sing();  // 歌を習って歌う
    let f2 = dance();           // ダンスする
    futures::join!(f1, f2);
}

fn main() {
    block_on(async_main());
}

-----------------------------------------------
■クレート(crate)

クレート は聞きなれない言葉ですが「木箱」の意味で、
他言語で言うところのパッケージ、モジュール、ライブラリを意味します
例えばランダム値を生成する rand クレートを使用するには次のようにします。

use rand::Rng;

fn main() {
    let mut rng = rand::thread_rng();
    for _i in 1..10 {
        println!("{}", rng.gen_range(1, 101));
    }
}

上記だけだと E0432(unresolved import) エラーが出てしまいますので、
Cargo プロジェクトで作成した Cargo.toml に次の1行を追記します。
追記後、cargo build または cargo run すると必要なクレートが自動的にダウンロードされてコンパイルされます。

[dependencies]
rand = "0.7"




-----------------------------------------------
■モジュール(mod, pub, use, as)

プログラムを複数のファイルに分割するにはモジュールを用います。
mod はモジュールを使用することを宣言します。
pub はモジュール外からもその名前にアクセスするために必要です。



-----------------------------------------------
■参照型(&, *)

& はその変数が指し示す値への参照を示します。
参照はポインタとも呼ばれます。
* は参照が指し示す値を示します。

let a = 123;
let p = &a;         // 123という値が格納された領域への参照をpに代入する
println!("{}", *p); // pが参照する領域の値(123)を出力する

ref を使用して次のようにも書けます。

let a = 123;
let ref p = a;
println!("{}", *p); // => 123

ミュータブルな参照を用いることで、参照先の値を変更することが可能となります。

let mut a = 123;    // ミュータブルな変数aを定義
let p = &mut a;     // ミュータブルな参照pを定義
*p = 456;           // 参照先の値を456に書き換える
println!("{}", a);  // => 456

-----------------------------------------------
■所有権・移動・参照・借用

Java や JavaScript などでは、ヒープ領域に確保したメモリは、
誰からも参照されなくなった後にガベージコレクションによって解放されますが、
Rust では、ただひとつの変数がヒープ上のメモリの 所有権(ownership) を持ち、
所有者がスコープから消えた時点でヒープ領域も開放されます。


-----
所有権の借用(borrowing)

借り方は2パターンあります。
・不変参照（immutable reference）
・可変参照（mutable reference）

// 不変参照の例1
let s = String::from("hello");
let t = &s;							// 不変参照
									// t はs の値の「参照」のみ許されます

// 不変参照の例2
fn f(t: &String) {
    println!("{}", t);
}

fn main() {
    let s = String::from("hello");
    f(&s);
    f(&s);
}

// 可変参照の例1
fn f(t: &mut String) {
    t.push('!');					//  t はs の値の「参照」「更新」が許されます
    println!("{}", t);
}

fn main() {
    let mut s = String::from("hello");
    f(&mut s);
    f(&mut s);
}

------
●所有権のルール
1.Rustの各値は、所有者と呼ばれる変数と対応している。
2.いかなる時も所有者は一つである。
3.所有者がスコープから外れたら、値は破棄される。

●参照のルール
4.任意のタイミングで、一つの可変参照 or 複数の不変参照の「どちらか」を行える。
	let mut s = String::from("hello");
	let t = &mut s;
	let u = &s; // compile error! (tが可変参照しているので)
	println!("{}", t);
5.参照は常に有効でなければならない。
	fn f() -> &String { // compile error! (関数が終わるとsの不変参照はドロップするので)
	    let s = String::from("hello");
	    return &s;
	}

	fn main() {
	    let t = f();
	    println!("{}", t);
}





-----------------------------------------------
■型エイリアス(type)

type を用いて型に 型エイリアス という別名をつけることができます。
ただし、異なる別名間の比較や代入でワーニングやエラーを出すことは無いようです。

-----------------------------------------------
■組み込み列挙型

Option
Result
など。
標準ライブラリで定義されている。
予約語ではない。

enum Option<T> {
    None,
    Some(T),
}

enum Result<T, E> {
    Ok(T),
    Err(E),
}

-----
Option<T>はよく使うので明示的にOption::と書かなくてもSomeが使える。
例えば、
let x = Some(10);
は、暗黙的に以下コードと解釈される。
let x:Option<i32> = Option::Some(10);

-----
Someから値を取り出す方法

let x = Some(5);

// パターンマッチ
match x {
    Some(val) => println!("The value is: {}", val),
    None => println!("There is no value"),
}

// unwrap
let value = x.unwrap();
let value = x.unwrap_or(0);
let value = x.unwrap_or_else(|| 10);



-----
Result はとてもよく使うので、Rust にはそれを扱うための強力な演算子 ? が用意されています。 
以下の2つのコードは等価です。

do_something_that_might_fail()?

match do_something_that_might_fail() {
    Ok(v) => v,
    Err(e) => return Err(e),
}


-----
Option/Result を使って作業するのは、ちょっとしたコードを書くのには厄介です。 
Option と Result の両方には unwrap と呼ばれる関数があり、手っ取り早く値を取得するのには便利です。 
unwrap は以下のことを行います。

Option/Result 内の値を取得します。
列挙型が None/Err の場合、panic! します。
以下の2つのコードは等価です。

my_option.unwrap()

match my_option {
    Some(v) => v,
    None => panic!("Rust によって生成されたエラーメッセージ！"),
}
同様に:

my_result.unwrap()

match my_result {
    Ok(v) => v,
    Err(e) => panic!("Rust によって生成されたエラーメッセージ！"),
}


-----------------------------------------------
■Vec


// 型を明示的に指定
let mut i32_vec = Vec::<i32>::new(); // turbofish <3
i32_vec.push(1);
i32_vec.push(2);
i32_vec.push(3);

// もっと賢く、型を自動的に推論
let mut float_vec = Vec::new();
float_vec.push(1.3);
float_vec.push(2.3);
float_vec.push(3.4);

// きれいなマクロ！ (vec!がマクロ)
let string_vec = vec![String::from("Hello"), String::from("World")];

for word in string_vec.iter() {
    println!("{}", word);
}


-----------------------------------------------
■メモリ関連

・ガベコレはない。
・スコープの終わりをリソースのデストラクトと解放の場所として使用します。
　→このデストラクトと解放のことをドロップ (drop) と呼びます。
・所有者が関数の実引数として渡されると、所有権は関数の仮引数に移動 (move) します。
　移動後は、元の関数内の変数は使用できなくなります。

		struct Foo {
		    x: i32,
		}

		fn do_something(f: Foo) {
		    println!("{}", f.x);
		    // f はここでドロップ
		}

		fn main() {
		    let foo = Foo { x: 42 };
		    // foo の所有権は do_something に移動
		    do_something(foo);
		    // foo は使えなくなる
		}

-----
・参照は、& 演算子を使ってリソースへのアクセスを借用できるようにしてくれます。
　参照も他のリソースと同様にドロップされます。

		struct Foo {
		    x: i32,
		}

		fn main() {
		    let foo = Foo { x: 42 };
		    let f = &foo;
		    println!("{}", f.x);
		    // f はここでドロップ
		    // foo はここでドロップ
		}

-----
・&mut 演算子を使えば、リソースへの変更可能なアクセスを借用することもできます。
　リソースの所有者は、可変な借用の間は移動や変更ができません。

		struct Foo {
		    x: i32,
		}

		fn do_something(f: Foo) {
		    println!("{}", f.x);
		    // f はここでドロップ
		}

		fn main() {
		    let mut foo = Foo { x: 42 };
		    let f = &mut foo;

		    // 失敗: do_something(foo) はここでエラー
		    // foo は可変に借用されており移動できないため

		    // 失敗: foo.x = 13; はここでエラー
		    // foo は可変に借用されている間は変更できないため

		    f.x = 13;
		    // f はここから先では使用されないため、ここでドロップ
		    
		    println!("{}", foo.x);
		    
		    // 可変な借用はドロップされているため変更可能
		    foo.x = 7;
		    
		    // foo の所有権を関数に移動
		    do_something(foo);
		}

-----
&mut による参照では、* 演算子によって参照を外す (dereference) ことで、所有者の値を設定できます。
* 演算子によって所有者の値のコピーを取得することもできます

		fn main() {
		    let mut foo = 42;
		    let f = &mut foo;
		    let bar = *f; // 所有者の値を取得
		    *f = 13;      // 参照の所有者の値を設定
		    println!("{}", bar);
		    println!("{}", foo);
		}

-----
●Rust の参照に関するルールは、以下のようにまとめられます。

Rust では、可変な参照が 1 つだけか、不変な参照が複数かのどちらかが許可されます。両方を同時には使用できません。
参照は所有者よりも長く存在してはなりません。

		struct Foo {
		    x: i32,
		}

		fn do_something(f: &mut Foo) {
		    f.x += 1;
		    // f への可変な参照はここでドロップ
		}

		fn main() {
		    let mut foo = Foo { x: 42 };
		    do_something(&mut foo);
		    // 関数 do_something で可変な参照はドロップされるため、
		    // 別の参照を作ることが可能
		    do_something(&mut foo);
		    // foo はここでドロップ
		    
		    println!("{}", foo.x);
		}


-----
● 所有権と関数

・スカラー値はコピーとなり、オブジェクトはムーブとなる。

// 例1
let x = 2;
let y = x;		// コピー (x, yともに2である)
println!("x:{}, y:{}", x, y);

let mut a = String::from("hoge");
let b = a;		// ムーブ
				// この時点でaは空
println!("{}", b);
//println!("{}", a);	// エラー(aはムーブされているので値がない)


// 例2
fn main() {
    let s = String::from("hello");  // sがスコープに入る

    takes_ownership(s);             // sの値が関数にムーブされ...
                                    // ... ここではもう有効ではない

    let x = 5;                      // xがスコープに入る

    makes_copy(x);                  // xも関数にムーブされるが、
                                    // i32はCopyなので、この後にxを使っても
                                    // 大丈夫
    println!("x={}", x);    // 5

} // ここでxがスコープを抜け、sもスコープを抜ける。ただし、sの値はムーブされているので、何も特別なことは起こらない。
  //

fn takes_ownership(some_string: String) { // some_stringがスコープに入る。
    println!("{}", some_string);
} // ここでsome_stringがスコープを抜け、`drop`が呼ばれる。後ろ盾してたメモリが解放される。
  // 

fn makes_copy(some_integer: i32) { // some_integerがスコープに入る
    println!("{}", some_integer);
} // ここでsome_integerがスコープを抜ける。何も特別なことはない。


-----
● 戻り値とスコープ

値を返すことでも、所有権は移動します。

fn main() {
    let s1 = gives_ownership();         // gives_ownershipは、戻り値をs1に
                                        // ムーブする

    let s2 = String::from("hello");     // s2がスコープに入る

    let s3 = takes_and_gives_back(s2);  // s2はtakes_and_gives_backにムーブされ
                                        // 戻り値もs3にムーブされる
} // ここで、s3はスコープを抜け、ドロップされる。s2もスコープを抜けるが、ムーブされているので、
  // 何も起きない。s1もスコープを抜け、ドロップされる。

fn gives_ownership() -> String {             // gives_ownershipは、戻り値を
                                             // 呼び出した関数にムーブする

    let some_string = String::from("hello"); // some_stringがスコープに入る

    some_string                              // some_stringが返され、呼び出し元関数に
                                             // ムーブされる
}

// takes_and_gives_backは、Stringを一つ受け取り、返す。
fn takes_and_gives_back(a_string: String) -> String { // a_stringがスコープに入る。

    a_string  // a_stringが返され、呼び出し元関数にムーブされる
}

-----
●参照と借用

ムーブされないようにするには、参照渡しで関数に渡す。
関数の引数に参照を取ることを借用と呼びます。
参照のデフォルトはイミュータブル（不変）なので、更新はできない。

fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);			// &を付けて参照渡し

    // '{}'の長さは、{}です
    println!("The length of '{}' is {}.", s1, len);		// ムーブされていないのでs1は使える
}

fn calculate_length(s: &String) -> usize {		// 関数の引数にも&をつける。sはStringへの参照
    s.len()										// 参照できる
    //s.push_str("add");						// これはエラー。更新はできない。
}												// ここで、sはスコープ外になる。
												// けど、参照しているものの所有権を持っているわけではないので
												// 何も起こらない

-----
●可変参照

参照にもmutをつければミュータブル（可変）になる。

fn main() {
    let mut s = String::from("hello");	// mutをつけておく

    change(&mut s);						// &mutで可変参照
}

fn change(some_string: &mut String) {	// 関数の引数にもつける
    some_string.push_str(", world");	// 更新できる
}

※注意点：可変参照は、1つしか作れない。

let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s;			// エラー

println!("{}, {}", r1, r2);


以下のようにスコープが別なら少しはまし。

let mut s = String::from("hello");

{
    let r1 = &mut s;

} // r1はここでスコープを抜けるので、問題なく新しい参照を作ることができる

let r2 = &mut s;



不変と可変の参照も同時には使えない。

let mut s = String::from("hello");

let r1 = &s; // 問題なし
let r2 = &s; // 問題なし
let r3 = &mut s; // 大問題！





-----
●参照外し

&による参照の逆。*をつける。






-----------------------------------------------
■ジェネリック

<T>とか、<f32>とかにみたい<>で囲む。
Tは、T固定ではない。（何でもよい。_でもよい。）

-----------------------------------------------
■cargo

ビルドシステム兼パッケージマネージャ

-----------------------------------------------
■式と文

Rustは式ベースの言語。
ほとんどが 式 （expression）で表されます．

・式
  - 何かしらの値を返します

  例.
    6		// 最小の式
    {}		// スコープを表すブロックも式
    if		// if文ではなく、if式
            // なので、以下も可能。
            // let a = if true { 5 } else { 3 };

・文
  - セミコロンで終端された文は強制的に () 型となる。
  - 処理を実行しますが値を返しません
  - 関数定義、マクロ




-----------------------------------------------
■マクロ

println!
panic!
assert_eq!
format!
vec!


Rust memo

å‚è€ƒï¼š
https://www.tohoho-web.com/ex/rust.html#as
https://tourofrust.com/TOC_ja.html

-----------------------------------------------
â– é–‹ç™ºç’°å¢ƒæ§‹ç¯‰

1.Microsoft C++ Build Toolsã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
   https://visualstudio.microsoft.com/ja/visual-cpp-build-tools/
   â†’C++ã ã‘å…¥ã‚Œã‚‹

2.Rustã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
   https://www.rust-lang.org/tools/install
   â†’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ©å©ã„ã¦ã€1 + Enter

3.Visual Studio Codeï¼ˆVSCodeï¼‰ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

4;æ‹¡å¼µæ©Ÿèƒ½ã€Œrust-analyzerã€ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

5;æ‹¡å¼µæ©Ÿèƒ½ã€ŒCodeLLDBã€ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

-----------------------------------------------
â– Hello world

1.é©å½“ã«ãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½œæˆã—ã¦CD

2.ä»¥ä¸‹ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œ
  >cargo new hello

  â†’src\main.rs
    ãªã©ãŒä½œæˆã•ã‚Œã‚‹ã€‚

3.VSCodeã§ä½œæˆã—ãŸãƒ•ã‚©ãƒ«ãƒ€ã‚’é–‹ã

3.F5ã§å®Ÿè¡Œ
  â†’åˆå›å®Ÿè¡Œæ™‚ã¯ã€launch.jsonãŒãªã„ã®ã§ã‚¨ãƒ©ãƒ¼ãŒå‡ºã‚‹ã€‚
    Yes/No/Cancelã®ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã§Yesã‚’æŠ¼ã›ã°ä½œã‚‰ã‚Œã‚‹ã€‚

-----------------------------------------------
â– å­¦ç¿’
å…¬å¼ãŒã‚ã‹ã‚Šã‚„ã™ã„ï¼
https://doc.rust-jp.rs/book-ja/index.html

-----------------------------------------------
â– äºˆç´„èª

as          // å‹å¤‰æ›
as          // ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åˆ¥å
async       // éåŒæœŸå‡¦ç†
await       // éåŒæœŸå‡¦ç†
break       // ãƒ«ãƒ¼ãƒ—ã‹ã‚‰æŠœã‘ã‚‹
const       // å¤‰æ•°ãƒ»å®šæ•°
continue    // æ¬¡ã®ãƒ«ãƒ¼ãƒ—ã‚’ç¶šã‘ã‚‹
crate       // ãƒ«ãƒ¼ãƒˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
dyn         // ãƒˆãƒ¬ã‚¤ãƒˆã®ç›´æ¥åˆ©ç”¨
else        // æ¡ä»¶åˆ†å²
enum        // åˆ—æŒ™å‹
extern      // å¤–éƒ¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒª
false       // çœŸå½å€¤ã®å½
fn          // é–¢æ•°
for         // ç¹°ã‚Šè¿”ã—
if          // æ¡ä»¶åˆ†å²
impl        // ã‚¤ãƒ³ãƒ—ãƒªãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³
in          // ç¹°ã‚Šè¿”ã—
let         // å¤‰æ•°ãƒ»å®šæ•°
loop        // ãƒ«ãƒ¼ãƒ—
match       // ãƒãƒƒãƒ â€»switchã®é«˜æ©Ÿèƒ½ç‰ˆ
mod         // ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®šç¾©
move        // ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã«æ‰€æœ‰æ¨©ã‚’å¼•ãæ¸¡ã™
mut         // å¤‰æ•°ãƒ»å®šæ•°
pub         // ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å¤–å…¬é–‹
ref         // å‚ç…§å‹
return      // é–¢æ•°ã®æˆ»ã‚Šå€¤
Self        // å®Ÿè£…ã«ãŠã‘ã‚‹è‡ªåˆ†ã®å‹
self        // è‡ªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
self        // è‡ªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
static      // é™çš„å¤‰æ•°
struct      // æ§‹é€ ä½“
super       // è¦ªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
trait       // ãƒˆãƒ¬ã‚¤ãƒˆ
true        // çœŸå½å€¤ã®çœŸ
type        // å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹
union       // å…±ç”¨ä½“
unsafe      // éå®‰å…¨ã‚³ãƒ¼ãƒ‰
use         // ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä½¿ç”¨		C#ã®usingã¨åŒã˜
where       // å‹ã‚’å¼·è¦ã™ã‚‹
while       // ç¹°ã‚Šè¿”ã—

-----------------------------------------------
â– ã‚³ãƒ¡ãƒ³ãƒˆ

//ãƒ©ã‚¤ãƒ³ã‚³ãƒ¡ãƒ³ãƒˆ

/* è¤‡æ•°è¡Œ
   ã‚³ãƒ¡ãƒ³ãƒˆ */

/// 3é€£ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã¯rustdocã«ã‚ˆã‚‹ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã«åˆ©ç”¨ã•ã‚Œã¾ã™

-----------------------------------------------
â– å‹

bool            // çœŸå½å€¤(true/false)
i8              // ç¬¦å·ä»˜ã8ãƒ“ãƒƒãƒˆæ•´æ•°
u8              // ç¬¦å·ç„¡ã—8ãƒ“ãƒƒãƒˆæ•´æ•°
i16             // ç¬¦å·ä»˜ã16ãƒ“ãƒƒãƒˆæ•´æ•°
u16             // ç¬¦å·ç„¡ã—16ãƒ“ãƒƒãƒˆæ•´æ•°
i32             // ç¬¦å·ä»˜ã32ãƒ“ãƒƒãƒˆæ•´æ•°
u32             // ç¬¦å·ç„¡ã—32ãƒ“ãƒƒãƒˆæ•´æ•°
i64             // ç¬¦å·ä»˜ã64ãƒ“ãƒƒãƒˆæ•´æ•°
u64             // ç¬¦å·ç„¡ã—64ãƒ“ãƒƒãƒˆæ•´æ•°
i128            // ç¬¦å·ä»˜ã128ãƒ“ãƒƒãƒˆæ•´æ•°
u128            // ç¬¦å·ç„¡ã—128ãƒ“ãƒƒãƒˆæ•´æ•°
isize           // ãƒã‚¤ãƒ³ã‚¿ã‚µã‚¤ã‚ºã¨åŒã˜ç¬¦å·ä»˜ãæ•´æ•° (CPUã«ã‚ˆã‚‹ã€‚64bitCPUãªã‚‰64bit)
usize           // ãƒã‚¤ãƒ³ã‚¿ã‚µã‚¤ã‚ºã¨åŒã˜ç¬¦å·ç„¡ã—æ•´æ•° (åŒä¸Š)
f32             // 32ãƒ“ãƒƒãƒˆæµ®å‹•å°æ•°ç‚¹æ•°
f64             // 64ãƒ“ãƒƒãƒˆæµ®å‹•å°æ•°ç‚¹æ•°
char            // æ–‡å­—(U+0000ï½U+D7FF, U+E000ï½U+10FFFF)
str             // æ–‡å­—åˆ—(&strã¨ã—ã¦ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒå¤šã„)		UTF-8
(type, type, .) // ã‚¿ãƒ—ãƒ«
[type; len]     // é…åˆ—
Vec<type>       // ãƒ™ã‚¯ã‚¿
&type           // typeã¸ã®å‚ç…§
&mut type       // typeã¸ã®ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªå‚ç…§
&[type]         // typeå‹è¦ç´ ã‚’æŒã¤ã‚¹ãƒ©ã‚¤ã‚¹

'				// ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ æŒ‡å®šå­
'static			// 


-----------------------------------------------
â– å€¤

true            // çœŸå½å€¤ã®çœŸ(bool)
false           // çœŸå½å€¤ã®å½(bool)
12345           // æ•´æ•°
12_345_678      // ã‚«ãƒ³ãƒã®ä»£ã‚ã‚Šã«_ã‚’ä½¿ç”¨ã—ã¦èª­ã¿ã‚„ã™ã
12345u32        // u32å‹ã®12345
0xfff           // 16é€²æ•°
0o777           // 8é€²æ•°
0b11001100      // 2é€²æ•°
'ã‚'            // æ–‡å­—(char)
"..."           // æ–‡å­—åˆ—(&str)
r"..."          // rawæ–‡å­—åˆ—
r#"..."#        // ãƒ€ãƒ–ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆã‚’ãã®ã¾ã¾ä½¿ç”¨ã§ãã‚‹æ–‡å­—åˆ—
b'a'            // 1ãƒã‚¤ãƒˆæ–‡å­—(u8)
b"abc"          // ãƒã‚¤ãƒˆé…åˆ—(&[u8])
br"..."         // rawãƒã‚¤ãƒˆé…åˆ—(&[u8])
-----------------------------------------------
â– å¤‰æ•°ãƒ»å®šæ•°(let, mut, const)

let n = 0;      // å¤‰æ›´ä¸å¯ï¼ˆã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«)å¤‰æ•°

let mut n = 0;  // å¤‰æ›´å¯èƒ½ãª(ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«)å¤‰æ•°

const MAX_POINTS: u32 = 100_000;        // å®šæ•°

-----------------------------------------------
â– å‹å¤‰æ›(as)

let x: i32 = 123;
let y: i64 = x as i64;

-----------------------------------------------
â– æ¼”ç®—å­(+ - ...)

-expr               // è² æ•°
expr + expr         // åŠ ç®—
expr - expr         // æ¸›ç®—
expr * expr         // ä¹—ç®—
expr / expr         // é™¤ç®—
expr % expr         // å‰°ä½™
expr & expr         // è«–ç†ç©(AND)
expr | expr         // è«–ç†å’Œ(OR)
expr ^ expr         // æ’ä»–çš„è«–ç†å’Œ(XOR)
expr << expr        // ãƒ“ãƒƒãƒˆå·¦ã‚·ãƒ•ãƒˆ
expr >> expr        // ãƒ“ãƒƒãƒˆå³ã‚·ãƒ•ãƒˆ
var = expr          // ä»£å…¥
var += expr         // var = var + expr ã¨åŒç¾©
var -= expr         // var = var - expr ã¨åŒç¾©
var *= expr         // var = var * expr ã¨åŒç¾©
var /= expr         // var = var / expr ã¨åŒç¾©
var %= expr         // var = var % expr ã¨åŒç¾©
var &= expr         // var = var & expr ã¨åŒç¾©
var |= expr         // var = var | expr ã¨åŒç¾©
var ^= expr         // var = var ^ expr ã¨åŒç¾©
var <<= expr        // var = var << expr ã¨åŒç¾©
var >>= expr        // var = var >> expr ã¨åŒç¾©
expr == expr        // æ¯”è¼ƒï¼šç­‰ã—ã„
expr != expr        // æ¯”è¼ƒï¼šç­‰ã—ããªã„
expr < expr         // æ¯”è¼ƒï¼šã‚ˆã‚Šå¤§ãã„
expr <= expr        // æ¯”è¼ƒï¼šä»¥ä¸Š
expr > expr         // æ¯”è¼ƒï¼šã‚ˆã‚Šå°ã•ã„
expr >= expr        // æ¯”è¼ƒï¼šä»¥ä¸‹
expr && expr        // ã‹ã¤(AND)
expr || expr        // ã¾ãŸã¯(OR)
!expr               // å¦å®š(NOT)

fn(...) -> type     // é–¢æ•°ã®å‹å®šç¾©
expr;               // è¡Œã®çµ‚ã‚ã‚Š
'label              // ãƒ©ãƒ™ãƒ«
expr..expr          // ç¯„å›²
macro!(...)         // ãƒã‚¯ãƒ­å‘¼ã³å‡ºã—		println!()ã‚„panic!()ã‚‚ãƒã‚¯ãƒ­ã€‚
macro![...]         // ãƒã‚¯ãƒ­å‘¼ã³å‡ºã—
macro!{...}         // ãƒã‚¯ãƒ­å‘¼ã³å‡ºã—
[type; len]         // é…åˆ—


pat => expr
expr?
&expr
&type
*expr				// å‚ç…§å¤–ã—æ¼”ç®—å­
*type
trait + trait
expr , expr
expr.ident
expr..=expr
..expr
variant(..)
expr...expr
ident: expr
ident @
pat | pat

::					// ã‚¹ã‚³ãƒ¼ãƒ—æ¼”ç®—å­
::<Type>			// Turbo Fish (ã‚¿ãƒ¼ãƒœãƒ•ã‚£ãƒƒã‚·ãƒ¥)
					// â†’Genericé–¢æ•°ã‚’å‘¼ã³å‡ºã™ã¨ãã«å¿…è¦ã€‚


-----------------------------------------------
â– æ§‹é€ ä½“(struct)   â€»ã‚¯ãƒ©ã‚¹ã¿ãŸã„ãªã‚‚ã®

struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 100, y: 200 };
    println!("{} {}", p.x, p.y);
}

----
..è¨˜æ³•

æ§‹é€ ä½“æ›´æ–°è¨˜æ³•ã‚’ä½¿ç”¨ã—ã¦ã€

let user2 = User {
    email: String::from("another@example.com"),
    username: String::from("anotherusername567"),
    ..user1			// æ–°ã—ã„Userã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç”¨ã®å€¤ã«æ–°ã—ã„emailã¨usernameã‚’ã‚»ãƒƒãƒˆã—ã¤ã¤ã€ 
					// æ®‹ã‚Šã®å€¤ã¯ã€user1å¤‰æ•°ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å€¤ã‚’ä½¿ã†
};

----
ã‚¿ãƒ—ãƒ«æ§‹é€ ä½“

struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);

----
ãƒ¦ãƒ‹ãƒƒãƒˆæ§˜æ§‹é€ ä½“

ä¸€åˆ‡ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ãªã„æ§‹é€ ä½“

----
æ§‹é€ ä½“ã‚’printlnã™ã‚‹ã«ã¯

#[derive(Debug)]			// ã‚­ãƒ¢
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!("rect1 is {:?}", rect1);		// ã‚­ãƒ¢ ({:?})  â†’{:#?}ã§ã‚‚è‰¯ã„ã€‚
}

-----
ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ     â€»ã‚ˆã†ã™ã‚‹ã«public method

#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {						// ã‚­ãƒ¢		impl
    fn area(&self) -> u32 {				// ã‚­ãƒ¢		&self
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}

-----
é–¢é€£é–¢æ•°   â€»ã‚ˆã†ã™ã‚‹ã«public static method

impl Rectangle {
    fn square(size: u32) -> Rectangle {				// ã‚­ãƒ¢   selfãŒãªã„ã ã‘ã€‚
        Rectangle { width: size, height: size }
    }
}

å‘¼ã³å‡ºã—ã¯::ã‚’ä½¿ã†ã€‚
let sq = Rectangle::square(3);


-----
è¤‡æ•°ã®implãƒ–ãƒ­ãƒƒã‚¯

åˆ†å‰²ã—ã¦æ›¸ã„ã¦ã‚‚ã‚ˆã„ã€‚â€»ã‚ˆã†ã¯partial class

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

------
struct QuitMessage; // ãƒ¦ãƒ‹ãƒƒãƒˆæ§‹é€ ä½“
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // ã‚¿ãƒ—ãƒ«æ§‹é€ ä½“
struct ChangeColorMessage(i32, i32, i32); // ã‚¿ãƒ—ãƒ«æ§‹é€ ä½“




-----------------------------------------------
â– åˆ—æŒ™å‹(enum)

enum Color {
    Red,
    Green,
    Blue,
}
let color = Color::Red;

----
ãƒ‡ãƒ¼ã‚¿æ ¼ç´

// ä¾‹1
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from("::1"));

// ä¾‹2
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

----
ãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©

impl Message {
    fn call(&self) {
        // method body would be defined here
        // ãƒ¡ã‚½ãƒƒãƒ‰æœ¬ä½“ã¯ã“ã“ã«å®šç¾©ã•ã‚Œã‚‹
    }
}

let m = Message::Write(String::from("hello"));
m.call();

----



-----------------------------------------------
â– ã‚¿ãƒ—ãƒ«(tup)

let tup = (10, "20", 30);
println!("{} {} {}", tup.0, tup.1, tup.2);

// åˆ†é…
let (x, y, z) = tup;
println!("y={}", y);	// 20




-----------------------------------------------
â– é…åˆ—(array)

let arr = [10, 20, 30];
println!("{} {} {}", arr[0], arr[1], arr[2]);

for v in &arr {
    println!("{}", v);
}

-----------------------------------------------
â– ãƒ™ã‚¯ã‚¿(vec)

let mut vect = vec![10, 20, 30];
vect.push(40);
println!("{} {} {} {}", vect[0], vect[1], vect[2], vect[3]);

for v in &vect {
    println!("{}", v);
}

-----------------------------------------------
â– ãƒãƒƒã‚·ãƒ¥ãƒãƒƒãƒ—(HashMap)

use std::collections::HashMap;
let mut map = HashMap::new();
map.insert("x", 10);
map.insert("y", 20);
map.insert("z", 30);
println!("{} {} {}", map["x"], map["y"], map["z"]);

for (k, v) in &map {
    println!("{} {}", k, v);
}

-----------------------------------------------
â– æ–‡å­—åˆ—(&str, String)

let mut name: &str = "Yamada";
name = "Tanaka";


----
ç”Ÿæ–‡å­—åˆ—ã§ã¯ã€r#"ã§å§‹ã¾ã‚Š"#ã§çµ‚ã‚ã‚‹æ–‡å­—åˆ—ã‚’é€èªçš„ã«æ›¸ãã“ã¨ãŒã§ãã¾ã™ã€‚ 
ã“ã‚Œã«ã‚ˆã£ã¦ã€é€šå¸¸ã®æ–‡å­—åˆ—ã¨ã®åŒºåˆ¥ãŒã¤ã‹ãªã„å¯èƒ½æ€§ã®ã‚ã‚‹æ–‡å­—ã‚’ãƒªãƒ†ãƒ©ãƒ«ã¨ã—ã¦æŒ¿å…¥ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
(äºŒé‡å¼•ç”¨ç¬¦ã‚„ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ãªã©)

fn main() {
    let a: &'static str = r#"
        <div class="advice">
            ç”Ÿæ–‡å­—åˆ—ã¯æ§˜ã€…ãªå ´é¢ã§å½¹ã«ç«‹ã¡ã¾ã™ã€‚
        </div>
        "#;
    println!("{}", a);
}
----
ã‚¹ãƒ©ã‚¤ã‚¹

fn main() {
    let a = "hi ğŸ¦€";
    println!("{}", a.len());
    let first_word = &a[0..2];
    let second_word = &a[3..7];
    // let half_crab = &a[3..5]; ã¯å¤±æ•—ã—ã¾ã™ã€‚
    // Rust ã¯ç„¡åŠ¹ãª unicode æ–‡å­—ã®ã‚¹ãƒ©ã‚¤ã‚¹ã‚’å—ã‘ä»˜ã‘ã¾ã›ã‚“ã€‚
    println!("{} {}", first_word, second_word);
}

----





-----------------------------------------------
â– ãƒ’ãƒ¼ãƒ—é ˜åŸŸ(Box)

struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p: Box<Point> = Box::new(Point { x: 100, y: 200 });
    println!("{} {}", p.x, p.y);
}

-----------------------------------------------
â– ã‚¹ãƒ©ã‚¤ã‚¹(&var[n..m])

æ‰€æœ‰æ¨©ã®ãªã„ãƒ‡ãƒ¼ã‚¿å‹
Stringã®ä¸€éƒ¨ã¸ã®ä¸å¤‰ã®å‚ç…§

let s = String::from("ABCDEFGH");
let s1 = &s[0..3];              // 0ç•ªç›®ã‹ã‚‰3ç•ªç›®ã®æ‰‹å‰ã¾ã§ã®ã‚¹ãƒ©ã‚¤ã‚¹("ABC")
let s2 = &s[3..6];              // 3ç•ªç›®ã‹ã‚‰6ç•ªç›®ã®æ‰‹å‰ã¾ã§ã®ã‚¹ãƒ©ã‚¤ã‚¹("DEF")
println!("{} {}", s1, s2);      // => ABC DEF

let a = [10, 20, 30, 40, 50, 60, 70, 80];
let a1 = &a[0..3];              // 0ç•ªç›®ã‹ã‚‰3ç•ªç›®ã®æ‰‹å‰ã¾ã§ã®ã‚¹ãƒ©ã‚¤ã‚¹[10, 20, 30]
let a2 = &a[3..6];              // 0ç•ªç›®ã‹ã‚‰3ç•ªç›®ã®æ‰‹å‰ã¾ã§ã®ã‚¹ãƒ©ã‚¤ã‚¹[40, 50, 60]
println!("{:?} {:?}", a1, a2);  // => [10, 20, 30] [40, 50, 60]


-----------------------------------------------
â– é–¢æ•°(fn)

fn add(x: i32, y: i32) -> i32 {
    return x + y;
}

// return ã•ã‚Œãªã„å ´åˆã¯ã€æœ€å¾Œã®å¼ãŒæˆ»ã‚Šå€¤ã¨ã—ã¦è¿”ã•ã‚Œã¾ã™ã€‚æœ€å¾Œã®ã‚»ãƒŸã‚³ãƒ­ãƒ³ ; ã¯è¨˜è¿°ã—ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚
fn add(x: i32, y: i32) -> i32 {
    x + y   // ã‚»ãƒŸã‚³ãƒ­ãƒ³(;)ç„¡ã—
}





-----------------------------------------------
â– ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼(|...|{...})

ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ ã¯ä»–ã®è¨€èªã§è¨€ã†ã¨ã“ã‚ã®ç„¡åé–¢æ•°ã‚„ãƒ©ãƒ ãƒ€å¼ã«ä¼¼ã¦ã„ã¾ã™ã€‚
ä¸‹è¨˜ã®ä¾‹ã§ã¯ x ã‚’å—ã‘å–ã‚Šã€ãã®äºŒä¹—ã‚’è¿”å´ã™ã‚‹ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’ square å¤‰æ•°ã«ä»£å…¥ã—ã€ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚

let square = | x: i32 | {
    x * x
};
println!("{}", square(9));



-----------------------------------------------
â– æ¡ä»¶åˆ†å²(if)

if n == 1 {
    println!("One");
} else if n == 2 {
    println!("Two");
} else {
    println!("Other");
}

-----------------------------------------------
â– ç¹°ã‚Šè¿”ã—(while)

let mut n = 0;
while n < 10 {
    n += 1;
}

-----------------------------------------------
â– ç¹°ã‚Šè¿”ã—(for)

for i in 0..10 {
    println!("{}", i);
}

-----------------------------------------------
â– ãƒ«ãƒ¼ãƒ—(loop)

let mut n = 0;
loop {
    n += 1;
    if n == 10 {
        break;
    }
}

----
ãƒ©ãƒ™ãƒ«ä»˜ã

fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {}", count);
        let mut remaining = 10;

        loop {
            println!("remaining = {}", remaining);
            if remaining == 9 {
                break;						// å†…å´ã®loopã‚’æŠœã‘ã‚‹
            }
            if count == 2 {
                break 'counting_up;			// ãƒ©ãƒ™ãƒ«ä»˜ãã®loopã‚’æŠœã‘ã‚‹
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {}", count);
}




-----------------------------------------------
â– ãƒ«ãƒ¼ãƒ—åˆ¶å¾¡(break, continue)

let mut n = 0;
loop {
    n += 1;
    if n == 2 {
        continue;
    }
    if n == 8 {
        break;
    }
    println!("{}", n);
}

-----------------------------------------------
â– ãƒãƒƒãƒ(match)

let x = 2;
match x {
    1 => println!("One"),
    2 => println!("Two"),
    3 => println!("Three"),
    _ => println!("More"),		// _ã¯switchæ–‡ã®defaultåŒã˜
}

-----
if let

æ¡ä»¶åˆ†å²ã‚’ç°¡æ½”ã«è¡Œã†

let mut count = 0;
match coin {
    // {:?}å·ã®ã‚¯ã‚©ãƒ¼ã‚¿ãƒ¼ã‚³ã‚¤ãƒ³
    Coin::Quarter(state) => println!("State quarter from {:?}!", state),
    _ => count += 1,
}
ã¯ã€if letã§ä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ã‘ã‚‹ã€‚

let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("State quarter from {:?}!", state);
} else {
    count += 1;
}



-----------------------------------------------
â– ã‚¤ãƒ³ãƒ—ãƒªãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³(impl)

Rust ã§ã¯ã‚¯ãƒ©ã‚¹ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ãŒã€
impl ã«ã‚ˆã£ã¦æ§‹é€ ä½“ã«ãƒ¡ã‚½ãƒƒãƒ‰ã‚’åŠ ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
self ã¯è‡ªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç¤ºã—ã¾ã™ã€‚

struct Rect { width: u32, height: u32 }

impl Rect {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let r = Rect { width: 200, height: 300 };
    println!("{}", r.area());
}

-----------------------------------------------
â– ãƒˆãƒ¬ã‚¤ãƒˆ(trait)

trait ã¯ç‰¹è³ªã®æ„å‘³ã§ã€æ§‹é€ ä½“ãŒå®Ÿè£…ã™ã¹ããƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¾ã™ã€‚
ä»–è¨€èªã® ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹(interface) ã«ä¼¼ã¦ã„ã¾ã™ã€‚
ä¾‹ãˆã°ã€std::fmt::Display ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ãŸæ§‹é€ ä½“ã¯ println!() ã® "{}" ã§ã€
std::fmt::Debug ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ãŸæ§‹é€ ä½“ã¯ "{:?}" ã§æ›¸ãå‡ºã™ã“ã¨ãŒå¯èƒ½ã§ã™ã€‚

struct Rect { width: u32, height: u32 }

trait Printable { fn print(&self); }
impl Printable for Rect {
    fn print(&self) {
        println!("width:{}, height:{}", self.width, self.height)
    }
}

fn main() {
    let r = Rect { width: 200, height: 300 };
    r.print();
}

ä¸Šè¨˜ã®ä¾‹ã§ã¯ u64 ã‚’æ‰±ã† Rect ã‚‚ç”¨æ„ã™ã‚‹ã«ã¯ impl Printable for RectU32 { ... } ã¨ 
impl Printable for RectU64 { ... } ã®äºŒã¤ã‚’å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ãŒã€
ä¸‹è¨˜ã®æ§˜ã«ã—ã¦ã€ä»»æ„ã®å‹ã‚’æŒã¤å®Ÿè£…ã‚’è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚
where ã¯ãã®å‹ãŒã€æŒ‡å®šã—ãŸãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ã¦ã„ã‚‹æ™‚ã®ã¿åˆ©ç”¨å¯èƒ½ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚

struct Rect<T> { width: T, height: T, }

trait Printable { fn print(&self); }
impl<T> Printable for Rect<T> where T: std::fmt::Display {
    fn print(self: &Rect<T>) {
        println!("{}x{}", self.width, self.height);
    }
}

fn main() {
    let r1: Rect<i32> = Rect{ width: 100, height: 200 };
    let r2: Rect<i64> = Rect{ width: 100, height: 200 };
    r1.print();
    r2.print();
}

-----
å¼•æ•°

pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        // "ï¼ˆ{}ã•ã‚“ã®æ–‡ç« ã‚’ã‚‚ã£ã¨èª­ã‚€ï¼‰"
        format!("(Read more from {}...)", self.summarize_author())
    }
}

pub fn notify(item: &impl Summary) {					// ã‚­ãƒ¢
    println!("Breaking news! {}", item.summarize());
}

-----
ãƒˆãƒ¬ã‚¤ãƒˆå¢ƒç•Œ

pub fn notify(item: &impl Summary) {ã®implã¯ã€ä»¥ä¸‹æ§‹æ–‡ï¼ˆãƒˆãƒ¬ã‚¤ãƒˆå¢ƒç•Œæ§‹æ–‡ã®ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ã‚·ãƒ¥ã‚¬ãƒ¼ï¼‰

pub fn notify<T: Summary>(item: &T) {


ã¾ãŸã€ä»¥ä¸‹ã®ã‚ˆã†ã«+ã§ãƒˆãƒ¬ã‚¤ãƒˆã‚’è¤‡æ•°æŒ‡å®šã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã€‚

pub fn notify<T: Summary + Display>(t: T) {		// pub fn notify(item: &(impl Summary + Display)) {ã§ã‚‚åŒã˜ã€‚
    // ...
}

-----
whereå¥

fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
ã®ã‚ˆã†ãªæ›¸ãæ–¹ã ã¨ã‚ã‹ã‚‰ã„ãšã‚‰ã„ã®ã§ã€whereå¥ã§ã‚¹ãƒƒã‚­ãƒªã•ã›ã‚‹ã€‚

fn some_function<T, U>(t: &T, u: &U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{




-----------------------------------------------
â– ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿(Iterator)

struct Counter {
    max: u32,
    count: u32,
}

impl Counter {
    fn new(max: u32) -> Counter {
        Counter { max: max, count: 0 }
    }
}

impl Iterator for Counter {
    type Item = u32;
    fn next(&mut self) -> Option<Self::Item> {
        self.count += 1;
        if self.count < self.max {
            Some(self.count)
        } else {
            None
        }
    }
}

fn main() {
    let counter = Counter::new(10);
    for c in counter {
        println!("{}", c);
    }
}

-----------------------------------------------
â– ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰(thread)

use std::thread;
use std::time::Duration;

fn main() {
    // ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’èµ·å‹•ã™ã‚‹
    // å¼•æ•°ã«ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼(ãƒ©ãƒ ãƒ€é–¢æ•°)ã‚’æŒ‡å®š
    let th = thread::spawn(|| {
        for _i in 1..10 {
            println!("A");
            thread::sleep(Duration::from_millis(100));
        }
    });
    th.join().unwrap();
    println!("Finished");
}

ã‚¹ãƒ¬ãƒƒãƒ‰ã‹ã‚‰ã‚¹ãƒ¬ãƒƒãƒ‰å¤–ã®å¤‰æ•°ã‚’å‚ç…§ã™ã‚‹ã«ã¯ã€
move ã«ã‚ˆã£ã¦å¤‰æ•°ã®æ‰€æœ‰æ¨©ã‚’ã‚¹ãƒ¬ãƒƒãƒ‰ã«å¼•ãæ¸¡ã™ã“ã¨ã‚’æ˜ç¤ºã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

fn main() {
    let str = String::from("ABC");
    let th = thread::spawn(move || {    // æ‰€æœ‰æ¨©ã‚’å¼•ãæ¸¡ã™ã“ã¨ã‚’æ˜ç¤º
        for _i in 1..10 {
            println!("{}", str);    // strã®æ‰€æœ‰æ¨©ã‚’å¾—ã‚‹
            thread::sleep(Duration::from_millis(100));
        }
    });
    th.join().unwrap();
    println!("Finished");
    // println!("{}", str);     // æ‰€æœ‰æ¨©ç§»å‹•æ¸ˆã®ãŸã‚ã‚¨ãƒ©ãƒ¼
}

-----------------------------------------------
â– éåŒæœŸé–¢æ•°(async, await)

async, await ã‚’ç”¨ã„ã¦éåŒæœŸé–¢æ•°ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
ä¸‹è¨˜ã¯ã€Rustã®èª¬æ˜æ›¸ ã«è¨˜è¼‰ã•ã‚Œã¦ã„ã‚‹ã‚µãƒ³ãƒ—ãƒ«ã§ã€æ­Œã‚’æ­Œã„ãªãŒã‚‰ãƒ€ãƒ³ã‚¹ãŒã§ãã‚‹ã‚ˆã†ã«æ›¸ã‹ã‚Œã¦ã„ã‚‹ã®ã§ã™ãŒã€
ã©ã†ã‚‚ã€æ­Œã„çµ‚ã‚ã£ã¦ã‹ã‚‰ã§ãªã„ã¨ãƒ€ãƒ³ã‚¹ã—ãªã„ã¿ãŸã„ã§ã€ã‚‚ã†å°‘ã—åˆ†ã‹ã‚Šã‚„ã™ã„ã‚·ãƒ³ãƒ—ãƒ«ãªã‚µãƒ³ãƒ—ãƒ«ã‚’
æä¾›ã§ãã‚‹æ–¹ã¯ãŠé¡˜ã„ã—ã¾ã™ã€‚

use futures::executor::block_on;

struct Song {
    lyric: String,
}

async fn learn_and_sing() {
    let song = learn_song().await;
    sing_song(song).await;
}

async fn learn_song() -> Song {
    let song = Song { lyric: String::from("La la la...") };
    println!("Learned song");
    return song;
}

async fn sing_song(song: Song) {
    println!("{}", song.lyric);
}

async fn dance() {
    println!("Dance");
}

async fn async_main() {
    let f1 = learn_and_sing();  // æ­Œã‚’ç¿’ã£ã¦æ­Œã†
    let f2 = dance();           // ãƒ€ãƒ³ã‚¹ã™ã‚‹
    futures::join!(f1, f2);
}

fn main() {
    block_on(async_main());
}

-----------------------------------------------
â– ã‚¯ãƒ¬ãƒ¼ãƒˆ(crate)

ã‚¯ãƒ¬ãƒ¼ãƒˆ ã¯èããªã‚Œãªã„è¨€è‘‰ã§ã™ãŒã€Œæœ¨ç®±ã€ã®æ„å‘³ã§ã€
ä»–è¨€èªã§è¨€ã†ã¨ã“ã‚ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã€ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’æ„å‘³ã—ã¾ã™
ä¾‹ãˆã°ãƒ©ãƒ³ãƒ€ãƒ å€¤ã‚’ç”Ÿæˆã™ã‚‹ rand ã‚¯ãƒ¬ãƒ¼ãƒˆã‚’ä½¿ç”¨ã™ã‚‹ã«ã¯æ¬¡ã®ã‚ˆã†ã«ã—ã¾ã™ã€‚

use rand::Rng;

fn main() {
    let mut rng = rand::thread_rng();
    for _i in 1..10 {
        println!("{}", rng.gen_range(1, 101));
    }
}

ä¸Šè¨˜ã ã‘ã ã¨ E0432(unresolved import) ã‚¨ãƒ©ãƒ¼ãŒå‡ºã¦ã—ã¾ã„ã¾ã™ã®ã§ã€
Cargo ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ä½œæˆã—ãŸ Cargo.toml ã«æ¬¡ã®1è¡Œã‚’è¿½è¨˜ã—ã¾ã™ã€‚
è¿½è¨˜å¾Œã€cargo build ã¾ãŸã¯ cargo run ã™ã‚‹ã¨å¿…è¦ãªã‚¯ãƒ¬ãƒ¼ãƒˆãŒè‡ªå‹•çš„ã«ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¾ã™ã€‚

[dependencies]
rand = "0.7"

-----
extern crate

å¤–éƒ¨ã®Rustãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’å‚ç…§ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚

extern crate <ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸å>;


-----------------------------------------------
â– ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«(mod, pub, use, as)

ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è¤‡æ•°ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«åˆ†å‰²ã™ã‚‹ã«ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ç”¨ã„ã¾ã™ã€‚
mod ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’å®£è¨€ã—ã¾ã™ã€‚
pub ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å¤–ã‹ã‚‰ã‚‚ãã®åå‰ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã«å¿…è¦ã§ã™ã€‚



-----------------------------------------------
â– å‚ç…§å‹(&, *)

& ã¯ãã®å¤‰æ•°ãŒæŒ‡ã—ç¤ºã™å€¤ã¸ã®å‚ç…§ã‚’ç¤ºã—ã¾ã™ã€‚
å‚ç…§ã¯ãƒã‚¤ãƒ³ã‚¿ã¨ã‚‚å‘¼ã°ã‚Œã¾ã™ã€‚
* ã¯å‚ç…§ãŒæŒ‡ã—ç¤ºã™å€¤ã‚’ç¤ºã—ã¾ã™ã€‚

let a = 123;
let p = &a;         // 123ã¨ã„ã†å€¤ãŒæ ¼ç´ã•ã‚ŒãŸé ˜åŸŸã¸ã®å‚ç…§ã‚’pã«ä»£å…¥ã™ã‚‹
println!("{}", *p); // pãŒå‚ç…§ã™ã‚‹é ˜åŸŸã®å€¤(123)ã‚’å‡ºåŠ›ã™ã‚‹

ref ã‚’ä½¿ç”¨ã—ã¦æ¬¡ã®ã‚ˆã†ã«ã‚‚æ›¸ã‘ã¾ã™ã€‚

let a = 123;
let ref p = a;
println!("{}", *p); // => 123

ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªå‚ç…§ã‚’ç”¨ã„ã‚‹ã“ã¨ã§ã€å‚ç…§å…ˆã®å€¤ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã¨ãªã‚Šã¾ã™ã€‚

let mut a = 123;    // ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªå¤‰æ•°aã‚’å®šç¾©
let p = &mut a;     // ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªå‚ç…§pã‚’å®šç¾©
*p = 456;           // å‚ç…§å…ˆã®å€¤ã‚’456ã«æ›¸ãæ›ãˆã‚‹
println!("{}", a);  // => 456

----
ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ 

å‚ç…§ãŒæœ‰åŠ¹ã«ãªã‚‹ã‚¹ã‚³ãƒ¼ãƒ—ã®ã“ã¨ã€‚

{
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {}", r); //          |
}                         // ---------+
ä¸Šè¨˜ä¾‹ã®å ´åˆã€xã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ (b)ã¯ã€rã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ (a)ã‚ˆã‚ŠçŸ­ã„ã®ã«ã€xã®å‚ç…§ã‚’ä½¿ãŠã†ã¨ã—ã¦ã„ã‚‹ã®ã§ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹ã€‚

-----
ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ æ³¨é‡ˆ

fn process_string<'a>(s: &'a str) -> &'a str {		// ã‚­ãƒ¢  'aãŒãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ æ³¨é‡ˆã€‚å¼•æ•°ã¨æˆ»ã‚Šå€¤ãŒåŒã˜ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã§ã‚ã‚‹ã“ã¨ã‚’æŒ‡å®šã€‚
    if s.len() > 5 {								// aã®éƒ¨åˆ†ã¯ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã®ã‚ˆã†ã«åŸºæœ¬çš„ã«ã¯ä½•ã§ã‚‚ã‚ˆã„ãŒã€æ…£ä¾‹ã¨ã—ã¦å°æ–‡å­—1æ–‡å­—ã®å ´åˆãŒå¤šã„ã€‚
        &s[0..5]
    } else {
        s
    }
}

fn main() {
    let s = "Hello, World!".to_string();
    let processed_string = process_string(&s);
    println!("{}", processed_string);
}
ã“ã®ä¾‹ã§ã¯ã€æ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ s ãŒé–¢æ•° process_string ã«æ¸¡ã•ã‚Œã¾ã™ã€‚
ã“ã®é–¢æ•°ã‹ã‚‰è¿”ã•ã‚Œã‚‹æ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ã¯ã€å‘¼ã³å‡ºã—å…ƒã®æ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ s ã«å¯¾å¿œã™ã‚‹ã‚‚ã®ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
ã—ã‹ã—ã€ã“ã®é–¢æ•°å†…ã§ã¯ã€æ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ s ã®é•·ã•ãŒ5ã‚ˆã‚Šå¤§ãã„å ´åˆã«ã€æœ€åˆã®5æ–‡å­—ã‚’è¿”ã™ã‚ˆã†ã«å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚
ã“ã®å ´åˆã€å‘¼ã³å‡ºã—å…ƒã®æ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ s ã¨ã¯ç•°ãªã‚‹ãƒ¡ãƒ¢ãƒªé ˜åŸŸã‚’å‚ç…§ã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚
          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ã“ã®ã‚ˆã†ãªå ´åˆã€Rustè¨€èªã§ã¯ã€å‘¼ã³å‡ºã—å…ƒã¨è¿”ã•ã‚Œã‚‹æ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ãŒåŒã˜ç”Ÿå­˜æœŸã‚’æŒã¤ã“ã¨ã‚’æ˜ç¤ºã™ã‚‹ãŸã‚ã«ã€
ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ æ³¨é‡ˆã‚’ä½¿ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ æ³¨é‡ˆã«ã‚ˆã£ã¦ã€å‘¼ã³å‡ºã—å…ƒã¨è¿”ã•ã‚Œã‚‹æ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ãŒåŒã˜ç”Ÿå­˜æœŸã‚’æŒã¤ã“ã¨ãŒä¿è¨¼ã•ã‚Œã‚‹ãŸã‚ã€
ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ã€æ­£ç¢ºãªãƒ¡ãƒ¢ãƒªã‚¢ã‚¯ã‚»ã‚¹ã‚’ä¿è¨¼ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚


&i32        // ãŸã ã®å‚ç…§
&'a i32     // æ˜ç¤ºçš„ãªãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ä»˜ãã®å‚ç…§
&'a mut i32 // æ˜ç¤ºçš„ãªãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ä»˜ãã®å¯å¤‰å‚ç…§


é–¢æ•°ã‹ã‚‰å‚ç…§ã‚’è¿”ã™éš›ã€æˆ»ã‚Šå€¤å‹ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ å¼•æ•°ã¯ã€å¼•æ•°ã®ã†ã¡ã©ã‚Œã‹ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ å¼•æ•°ã¨ä¸€è‡´ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ 
è¿”ã•ã‚Œã‚‹å‚ç…§ãŒå¼•æ•°ã®ã©ã‚Œã‹ã‚’å‚ç…§ã—ã¦ã„ãªã„ãªã‚‰ã°ã€ã“ã®é–¢æ•°å†…ã§ç”Ÿæˆã•ã‚ŒãŸå€¤ã‚’å‚ç…§ã—ã¦ã„ã‚‹ã¯ãšã§ã™ã€‚


----
æ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹

æ–‡å­—åˆ—ã®ä¸€éƒ¨åˆ†ã‚’è¡¨ã™ãƒ‡ãƒ¼ã‚¿å‹ã§ã™ã€‚
æ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ã¯æ–‡å­—åˆ—ï¼ˆStringå‹ï¼‰ã‹ã‚‰ç”Ÿæˆã•ã‚Œã‚‹ã‚‚ã®ã§ã€æ–‡å­—åˆ—ï¼ˆStringå‹ï¼‰ã‚’æ‰±ã†ã“ã¨ãªãã€æ–‡å­—åˆ—ã®ä¸€éƒ¨åˆ†ã‚’æ‰±ã„ã¾ã™ã€‚
æ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ã¯ã€æ–‡å­—åˆ—ï¼ˆStringå‹ï¼‰ã‹ã‚‰ç”Ÿæˆã™ã‚‹ãŸã‚ã«ã€æ–‡å­—åˆ—ã®ä¸­ã‹ã‚‰ç‰¹å®šã®ç¯„å›²ã‚’é¸æŠã™ã‚‹æ–¹æ³•ã¨ã—ã¦ã€
ã‚¹ãƒ©ã‚¤ã‚¹æ§‹æ–‡ &s[start..end] ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
ã“ã®ã‚¹ãƒ©ã‚¤ã‚¹æ§‹æ–‡ã§ç”Ÿæˆã•ã‚ŒãŸæ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ã¯ã€æ–‡å­—åˆ—ï¼ˆStringå‹ï¼‰ã‚’æ‰±ã†ã“ã¨ãªãã€
é¸æŠã•ã‚ŒãŸç¯„å›²ã®æ–‡å­—åˆ—ã‚’æ‰±ã†ã“ã¨ãŒã§ãã¾ã™ã€‚

let original_string = "Hello, World!".to_string();
let slice = &original_string[0..5];
println!("{}", slice);
ã“ã®ä¾‹ã§ã¯ã€æ–‡å­—åˆ— "Hello, World!" ã®æœ€åˆã®5æ–‡å­—ã‚’é¸æŠã—ã€æ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ slice ã«æ ¼ç´ã—ã¾ã™ã€‚
ãã—ã¦ã€ã“ã®æ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚











-----------------------------------------------
â– æ‰€æœ‰æ¨©ãƒ»ç§»å‹•ãƒ»å‚ç…§ãƒ»å€Ÿç”¨

Java ã‚„ JavaScript ãªã©ã§ã¯ã€ãƒ’ãƒ¼ãƒ—é ˜åŸŸã«ç¢ºä¿ã—ãŸãƒ¡ãƒ¢ãƒªã¯ã€
èª°ã‹ã‚‰ã‚‚å‚ç…§ã•ã‚Œãªããªã£ãŸå¾Œã«ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã«ã‚ˆã£ã¦è§£æ”¾ã•ã‚Œã¾ã™ãŒã€
Rust ã§ã¯ã€ãŸã ã²ã¨ã¤ã®å¤‰æ•°ãŒãƒ’ãƒ¼ãƒ—ä¸Šã®ãƒ¡ãƒ¢ãƒªã® æ‰€æœ‰æ¨©(ownership) ã‚’æŒã¡ã€
æ‰€æœ‰è€…ãŒã‚¹ã‚³ãƒ¼ãƒ—ã‹ã‚‰æ¶ˆãˆãŸæ™‚ç‚¹ã§ãƒ’ãƒ¼ãƒ—é ˜åŸŸã‚‚é–‹æ”¾ã•ã‚Œã¾ã™ã€‚


-----
æ‰€æœ‰æ¨©ã®å€Ÿç”¨(borrowing)

å€Ÿã‚Šæ–¹ã¯2ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚ã‚Šã¾ã™ã€‚
ãƒ»ä¸å¤‰å‚ç…§ï¼ˆimmutable referenceï¼‰
ãƒ»å¯å¤‰å‚ç…§ï¼ˆmutable referenceï¼‰

// ä¸å¤‰å‚ç…§ã®ä¾‹1
let s = String::from("hello");
let t = &s;							// ä¸å¤‰å‚ç…§
									// t ã¯s ã®å€¤ã®ã€Œå‚ç…§ã€ã®ã¿è¨±ã•ã‚Œã¾ã™

// ä¸å¤‰å‚ç…§ã®ä¾‹2
fn f(t: &String) {
    println!("{}", t);
}

fn main() {
    let s = String::from("hello");
    f(&s);
    f(&s);
}

// å¯å¤‰å‚ç…§ã®ä¾‹1
fn f(t: &mut String) {
    t.push('!');					//  t ã¯s ã®å€¤ã®ã€Œå‚ç…§ã€ã€Œæ›´æ–°ã€ãŒè¨±ã•ã‚Œã¾ã™
    println!("{}", t);
}

fn main() {
    let mut s = String::from("hello");
    f(&mut s);
    f(&mut s);
}

------
â—æ‰€æœ‰æ¨©ã®ãƒ«ãƒ¼ãƒ«
1.Rustã®å„å€¤ã¯ã€æ‰€æœ‰è€…ã¨å‘¼ã°ã‚Œã‚‹å¤‰æ•°ã¨å¯¾å¿œã—ã¦ã„ã‚‹ã€‚
2.ã„ã‹ãªã‚‹æ™‚ã‚‚æ‰€æœ‰è€…ã¯ä¸€ã¤ã§ã‚ã‚‹ã€‚
3.æ‰€æœ‰è€…ãŒã‚¹ã‚³ãƒ¼ãƒ—ã‹ã‚‰å¤–ã‚ŒãŸã‚‰ã€å€¤ã¯ç ´æ£„ã•ã‚Œã‚‹ã€‚

â—å‚ç…§ã®ãƒ«ãƒ¼ãƒ«
4.ä»»æ„ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ã€ä¸€ã¤ã®å¯å¤‰å‚ç…§ or è¤‡æ•°ã®ä¸å¤‰å‚ç…§ã®ã€Œã©ã¡ã‚‰ã‹ã€ã‚’è¡Œãˆã‚‹ã€‚
	let mut s = String::from("hello");
	let t = &mut s;
	let u = &s; // compile error! (tãŒå¯å¤‰å‚ç…§ã—ã¦ã„ã‚‹ã®ã§)
	println!("{}", t);
5.å‚ç…§ã¯å¸¸ã«æœ‰åŠ¹ã§ãªã‘ã‚Œã°ãªã‚‰ãªã„ã€‚
	fn f() -> &String { // compile error! (é–¢æ•°ãŒçµ‚ã‚ã‚‹ã¨sã®ä¸å¤‰å‚ç…§ã¯ãƒ‰ãƒ­ãƒƒãƒ—ã™ã‚‹ã®ã§)
	    let s = String::from("hello");
	    return &s;
	}

	fn main() {
	    let t = f();
	    println!("{}", t);
}





-----------------------------------------------
â– å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹(type)

type ã‚’ç”¨ã„ã¦å‹ã« å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹ ã¨ã„ã†åˆ¥åã‚’ã¤ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
ãŸã ã—ã€ç•°ãªã‚‹åˆ¥åé–“ã®æ¯”è¼ƒã‚„ä»£å…¥ã§ãƒ¯ãƒ¼ãƒ‹ãƒ³ã‚°ã‚„ã‚¨ãƒ©ãƒ¼ã‚’å‡ºã™ã“ã¨ã¯ç„¡ã„ã‚ˆã†ã§ã™ã€‚

-----------------------------------------------
â– çµ„ã¿è¾¼ã¿åˆ—æŒ™å‹

Option
Result
ãªã©ã€‚
æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã€‚
äºˆç´„èªã§ã¯ãªã„ã€‚

enum Option<T> {
    None,
    Some(T),
}

enum Result<T, E> {
    Ok(T),
    Err(E),
}

-----
Option<T>ã¯ã‚ˆãä½¿ã†ã®ã§æ˜ç¤ºçš„ã«Option::ã¨æ›¸ã‹ãªãã¦ã‚‚SomeãŒä½¿ãˆã‚‹ã€‚
ä¾‹ãˆã°ã€
let x = Some(10);
ã¯ã€æš—é»™çš„ã«ä»¥ä¸‹ã‚³ãƒ¼ãƒ‰ã¨è§£é‡ˆã•ã‚Œã‚‹ã€‚
let x:Option<i32> = Option::Some(10);

-----
Someã‹ã‚‰å€¤ã‚’å–ã‚Šå‡ºã™æ–¹æ³•

let x = Some(5);

// ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒ
match x {
    Some(val) => println!("The value is: {}", val),
    None => println!("There is no value"),
}

// unwrap
let value = x.unwrap();
let value = x.unwrap_or(0);
let value = x.unwrap_or_else(|| 10);



-----
Result ã¯ã¨ã¦ã‚‚ã‚ˆãä½¿ã†ã®ã§ã€Rust ã«ã¯ãã‚Œã‚’æ‰±ã†ãŸã‚ã®å¼·åŠ›ãªæ¼”ç®—å­ ? ãŒç”¨æ„ã•ã‚Œã¦ã„ã¾ã™ã€‚ 
ä»¥ä¸‹ã®2ã¤ã®ã‚³ãƒ¼ãƒ‰ã¯ç­‰ä¾¡ã§ã™ã€‚

do_something_that_might_fail()?

match do_something_that_might_fail() {
    Ok(v) => v,
    Err(e) => return Err(e),
}


-----
Option/Result ã‚’ä½¿ã£ã¦ä½œæ¥­ã™ã‚‹ã®ã¯ã€ã¡ã‚‡ã£ã¨ã—ãŸã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãã®ã«ã¯å„ä»‹ã§ã™ã€‚ 
Option ã¨ Result ã®ä¸¡æ–¹ã«ã¯ unwrap ã¨å‘¼ã°ã‚Œã‚‹é–¢æ•°ãŒã‚ã‚Šã€æ‰‹ã£å–ã‚Šæ—©ãå€¤ã‚’å–å¾—ã™ã‚‹ã®ã«ã¯ä¾¿åˆ©ã§ã™ã€‚ 
unwrap ã¯ä»¥ä¸‹ã®ã“ã¨ã‚’è¡Œã„ã¾ã™ã€‚

Option/Result å†…ã®å€¤ã‚’å–å¾—ã—ã¾ã™ã€‚
åˆ—æŒ™å‹ãŒ None/Err ã®å ´åˆã€panic! ã—ã¾ã™ã€‚
ä»¥ä¸‹ã®2ã¤ã®ã‚³ãƒ¼ãƒ‰ã¯ç­‰ä¾¡ã§ã™ã€‚

my_option.unwrap()

match my_option {
    Some(v) => v,
    None => panic!("Rust ã«ã‚ˆã£ã¦ç”Ÿæˆã•ã‚ŒãŸã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼"),
}
åŒæ§˜ã«:

my_result.unwrap()

match my_result {
    Ok(v) => v,
    Err(e) => panic!("Rust ã«ã‚ˆã£ã¦ç”Ÿæˆã•ã‚ŒãŸã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼"),
}


-----------------------------------------------
â– Vec


// å‹ã‚’æ˜ç¤ºçš„ã«æŒ‡å®š
let mut i32_vec = Vec::<i32>::new(); // turbofish <3
i32_vec.push(1);
i32_vec.push(2);
i32_vec.push(3);

// ã‚‚ã£ã¨è³¢ãã€å‹ã‚’è‡ªå‹•çš„ã«æ¨è«–
let mut float_vec = Vec::new();
float_vec.push(1.3);
float_vec.push(2.3);
float_vec.push(3.4);

// ãã‚Œã„ãªãƒã‚¯ãƒ­ï¼ (vec!ãŒãƒã‚¯ãƒ­)
let string_vec = vec![String::from("Hello"), String::from("World")];

for word in string_vec.iter() {
    println!("{}", word);
}

// Stringã®Vec
let a: Vec<String> = vec!["123".to_string(), "ABC".to_string()];
let b = &a[1];		// Stringå‹ã¯Copyãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ã¦ã„ãªã„ã®ã§ãƒ ãƒ¼ãƒ–ã«ãªã£ã¦ã—ã¾ã†ã€‚ãªã®ã§å‚ç…§ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
println!("{}", b);	// ABC


-----------------------------------------------
â– ãƒ¡ãƒ¢ãƒªé–¢é€£

ãƒ»ã‚¬ãƒ™ã‚³ãƒ¬ã¯ãªã„ã€‚
ãƒ»ã‚¹ã‚³ãƒ¼ãƒ—ã®çµ‚ã‚ã‚Šã‚’ãƒªã‚½ãƒ¼ã‚¹ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ãƒˆã¨è§£æ”¾ã®å ´æ‰€ã¨ã—ã¦ä½¿ç”¨ã—ã¾ã™ã€‚
ã€€â†’ã“ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ãƒˆã¨è§£æ”¾ã®ã“ã¨ã‚’ãƒ‰ãƒ­ãƒƒãƒ— (drop) ã¨å‘¼ã³ã¾ã™ã€‚
ãƒ»æ‰€æœ‰è€…ãŒé–¢æ•°ã®å®Ÿå¼•æ•°ã¨ã—ã¦æ¸¡ã•ã‚Œã‚‹ã¨ã€æ‰€æœ‰æ¨©ã¯é–¢æ•°ã®ä»®å¼•æ•°ã«ç§»å‹• (move) ã—ã¾ã™ã€‚
ã€€ç§»å‹•å¾Œã¯ã€å…ƒã®é–¢æ•°å†…ã®å¤‰æ•°ã¯ä½¿ç”¨ã§ããªããªã‚Šã¾ã™ã€‚

		struct Foo {
		    x: i32,
		}

		fn do_something(f: Foo) {
		    println!("{}", f.x);
		    // f ã¯ã“ã“ã§ãƒ‰ãƒ­ãƒƒãƒ—
		}

		fn main() {
		    let foo = Foo { x: 42 };
		    // foo ã®æ‰€æœ‰æ¨©ã¯ do_something ã«ç§»å‹•
		    do_something(foo);
		    // foo ã¯ä½¿ãˆãªããªã‚‹
		}

-----
ãƒ»å‚ç…§ã¯ã€& æ¼”ç®—å­ã‚’ä½¿ã£ã¦ãƒªã‚½ãƒ¼ã‚¹ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’å€Ÿç”¨ã§ãã‚‹ã‚ˆã†ã«ã—ã¦ãã‚Œã¾ã™ã€‚
ã€€å‚ç…§ã‚‚ä»–ã®ãƒªã‚½ãƒ¼ã‚¹ã¨åŒæ§˜ã«ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚Œã¾ã™ã€‚

		struct Foo {
		    x: i32,
		}

		fn main() {
		    let foo = Foo { x: 42 };
		    let f = &foo;
		    println!("{}", f.x);
		    // f ã¯ã“ã“ã§ãƒ‰ãƒ­ãƒƒãƒ—
		    // foo ã¯ã“ã“ã§ãƒ‰ãƒ­ãƒƒãƒ—
		}

-----
ãƒ»&mut æ¼”ç®—å­ã‚’ä½¿ãˆã°ã€ãƒªã‚½ãƒ¼ã‚¹ã¸ã®å¤‰æ›´å¯èƒ½ãªã‚¢ã‚¯ã‚»ã‚¹ã‚’å€Ÿç”¨ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚
ã€€ãƒªã‚½ãƒ¼ã‚¹ã®æ‰€æœ‰è€…ã¯ã€å¯å¤‰ãªå€Ÿç”¨ã®é–“ã¯ç§»å‹•ã‚„å¤‰æ›´ãŒã§ãã¾ã›ã‚“ã€‚

		struct Foo {
		    x: i32,
		}

		fn do_something(f: Foo) {
		    println!("{}", f.x);
		    // f ã¯ã“ã“ã§ãƒ‰ãƒ­ãƒƒãƒ—
		}

		fn main() {
		    let mut foo = Foo { x: 42 };
		    let f = &mut foo;

		    // å¤±æ•—: do_something(foo) ã¯ã“ã“ã§ã‚¨ãƒ©ãƒ¼
		    // foo ã¯å¯å¤‰ã«å€Ÿç”¨ã•ã‚Œã¦ãŠã‚Šç§»å‹•ã§ããªã„ãŸã‚

		    // å¤±æ•—: foo.x = 13; ã¯ã“ã“ã§ã‚¨ãƒ©ãƒ¼
		    // foo ã¯å¯å¤‰ã«å€Ÿç”¨ã•ã‚Œã¦ã„ã‚‹é–“ã¯å¤‰æ›´ã§ããªã„ãŸã‚

		    f.x = 13;
		    // f ã¯ã“ã“ã‹ã‚‰å…ˆã§ã¯ä½¿ç”¨ã•ã‚Œãªã„ãŸã‚ã€ã“ã“ã§ãƒ‰ãƒ­ãƒƒãƒ—
		    
		    println!("{}", foo.x);
		    
		    // å¯å¤‰ãªå€Ÿç”¨ã¯ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚Œã¦ã„ã‚‹ãŸã‚å¤‰æ›´å¯èƒ½
		    foo.x = 7;
		    
		    // foo ã®æ‰€æœ‰æ¨©ã‚’é–¢æ•°ã«ç§»å‹•
		    do_something(foo);
		}

-----
&mut ã«ã‚ˆã‚‹å‚ç…§ã§ã¯ã€* æ¼”ç®—å­ã«ã‚ˆã£ã¦å‚ç…§ã‚’å¤–ã™ (dereference) ã“ã¨ã§ã€æ‰€æœ‰è€…ã®å€¤ã‚’è¨­å®šã§ãã¾ã™ã€‚
* æ¼”ç®—å­ã«ã‚ˆã£ã¦æ‰€æœ‰è€…ã®å€¤ã®ã‚³ãƒ”ãƒ¼ã‚’å–å¾—ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™

		fn main() {
		    let mut foo = 42;
		    let f = &mut foo;
		    let bar = *f; // æ‰€æœ‰è€…ã®å€¤ã‚’å–å¾—
		    *f = 13;      // å‚ç…§ã®æ‰€æœ‰è€…ã®å€¤ã‚’è¨­å®š
		    println!("{}", bar);
		    println!("{}", foo);
		}

-----
â—Rust ã®å‚ç…§ã«é–¢ã™ã‚‹ãƒ«ãƒ¼ãƒ«ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã¾ã¨ã‚ã‚‰ã‚Œã¾ã™ã€‚

Rust ã§ã¯ã€å¯å¤‰ãªå‚ç…§ãŒ 1 ã¤ã ã‘ã‹ã€ä¸å¤‰ãªå‚ç…§ãŒè¤‡æ•°ã‹ã®ã©ã¡ã‚‰ã‹ãŒè¨±å¯ã•ã‚Œã¾ã™ã€‚ä¸¡æ–¹ã‚’åŒæ™‚ã«ã¯ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚
å‚ç…§ã¯æ‰€æœ‰è€…ã‚ˆã‚Šã‚‚é•·ãå­˜åœ¨ã—ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚

		struct Foo {
		    x: i32,
		}

		fn do_something(f: &mut Foo) {
		    f.x += 1;
		    // f ã¸ã®å¯å¤‰ãªå‚ç…§ã¯ã“ã“ã§ãƒ‰ãƒ­ãƒƒãƒ—
		}

		fn main() {
		    let mut foo = Foo { x: 42 };
		    do_something(&mut foo);
		    // é–¢æ•° do_something ã§å¯å¤‰ãªå‚ç…§ã¯ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚Œã‚‹ãŸã‚ã€
		    // åˆ¥ã®å‚ç…§ã‚’ä½œã‚‹ã“ã¨ãŒå¯èƒ½
		    do_something(&mut foo);
		    // foo ã¯ã“ã“ã§ãƒ‰ãƒ­ãƒƒãƒ—
		    
		    println!("{}", foo.x);
		}


-----
â— æ‰€æœ‰æ¨©ã¨é–¢æ•°

ãƒ»ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã¯ã‚³ãƒ”ãƒ¼ã¨ãªã‚Šã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ ãƒ¼ãƒ–ã¨ãªã‚‹ã€‚

// ä¾‹1
let x = 2;
let y = x;		// ã‚³ãƒ”ãƒ¼ (x, yã¨ã‚‚ã«2ã§ã‚ã‚‹)
println!("x:{}, y:{}", x, y);

let mut a = String::from("hoge");
let b = a;		// ãƒ ãƒ¼ãƒ–
				// ã“ã®æ™‚ç‚¹ã§aã¯ç©º
println!("{}", b);
//println!("{}", a);	// ã‚¨ãƒ©ãƒ¼(aã¯ãƒ ãƒ¼ãƒ–ã•ã‚Œã¦ã„ã‚‹ã®ã§å€¤ãŒãªã„)


// ä¾‹2
fn main() {
    let s = String::from("hello");  // sãŒã‚¹ã‚³ãƒ¼ãƒ—ã«å…¥ã‚‹

    takes_ownership(s);             // sã®å€¤ãŒé–¢æ•°ã«ãƒ ãƒ¼ãƒ–ã•ã‚Œ...
                                    // ... ã“ã“ã§ã¯ã‚‚ã†æœ‰åŠ¹ã§ã¯ãªã„

    let x = 5;                      // xãŒã‚¹ã‚³ãƒ¼ãƒ—ã«å…¥ã‚‹

    makes_copy(x);                  // xã‚‚é–¢æ•°ã«ãƒ ãƒ¼ãƒ–ã•ã‚Œã‚‹ãŒã€
                                    // i32ã¯Copyãªã®ã§ã€ã“ã®å¾Œã«xã‚’ä½¿ã£ã¦ã‚‚
                                    // å¤§ä¸ˆå¤«
    println!("x={}", x);    // 5

} // ã“ã“ã§xãŒã‚¹ã‚³ãƒ¼ãƒ—ã‚’æŠœã‘ã€sã‚‚ã‚¹ã‚³ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹ã€‚ãŸã ã—ã€sã®å€¤ã¯ãƒ ãƒ¼ãƒ–ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€ä½•ã‚‚ç‰¹åˆ¥ãªã“ã¨ã¯èµ·ã“ã‚‰ãªã„ã€‚
  //

fn takes_ownership(some_string: String) { // some_stringãŒã‚¹ã‚³ãƒ¼ãƒ—ã«å…¥ã‚‹ã€‚
    println!("{}", some_string);
} // ã“ã“ã§some_stringãŒã‚¹ã‚³ãƒ¼ãƒ—ã‚’æŠœã‘ã€`drop`ãŒå‘¼ã°ã‚Œã‚‹ã€‚å¾Œã‚ç›¾ã—ã¦ãŸãƒ¡ãƒ¢ãƒªãŒè§£æ”¾ã•ã‚Œã‚‹ã€‚
  // 

fn makes_copy(some_integer: i32) { // some_integerãŒã‚¹ã‚³ãƒ¼ãƒ—ã«å…¥ã‚‹
    println!("{}", some_integer);
} // ã“ã“ã§some_integerãŒã‚¹ã‚³ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹ã€‚ä½•ã‚‚ç‰¹åˆ¥ãªã“ã¨ã¯ãªã„ã€‚


-----
â— æˆ»ã‚Šå€¤ã¨ã‚¹ã‚³ãƒ¼ãƒ—

å€¤ã‚’è¿”ã™ã“ã¨ã§ã‚‚ã€æ‰€æœ‰æ¨©ã¯ç§»å‹•ã—ã¾ã™ã€‚

fn main() {
    let s1 = gives_ownership();         // gives_ownershipã¯ã€æˆ»ã‚Šå€¤ã‚’s1ã«
                                        // ãƒ ãƒ¼ãƒ–ã™ã‚‹

    let s2 = String::from("hello");     // s2ãŒã‚¹ã‚³ãƒ¼ãƒ—ã«å…¥ã‚‹

    let s3 = takes_and_gives_back(s2);  // s2ã¯takes_and_gives_backã«ãƒ ãƒ¼ãƒ–ã•ã‚Œ
                                        // æˆ»ã‚Šå€¤ã‚‚s3ã«ãƒ ãƒ¼ãƒ–ã•ã‚Œã‚‹
} // ã“ã“ã§ã€s3ã¯ã‚¹ã‚³ãƒ¼ãƒ—ã‚’æŠœã‘ã€ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚Œã‚‹ã€‚s2ã‚‚ã‚¹ã‚³ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹ãŒã€ãƒ ãƒ¼ãƒ–ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€
  // ä½•ã‚‚èµ·ããªã„ã€‚s1ã‚‚ã‚¹ã‚³ãƒ¼ãƒ—ã‚’æŠœã‘ã€ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚Œã‚‹ã€‚

fn gives_ownership() -> String {             // gives_ownershipã¯ã€æˆ»ã‚Šå€¤ã‚’
                                             // å‘¼ã³å‡ºã—ãŸé–¢æ•°ã«ãƒ ãƒ¼ãƒ–ã™ã‚‹

    let some_string = String::from("hello"); // some_stringãŒã‚¹ã‚³ãƒ¼ãƒ—ã«å…¥ã‚‹

    some_string                              // some_stringãŒè¿”ã•ã‚Œã€å‘¼ã³å‡ºã—å…ƒé–¢æ•°ã«
                                             // ãƒ ãƒ¼ãƒ–ã•ã‚Œã‚‹
}

// takes_and_gives_backã¯ã€Stringã‚’ä¸€ã¤å—ã‘å–ã‚Šã€è¿”ã™ã€‚
fn takes_and_gives_back(a_string: String) -> String { // a_stringãŒã‚¹ã‚³ãƒ¼ãƒ—ã«å…¥ã‚‹ã€‚

    a_string  // a_stringãŒè¿”ã•ã‚Œã€å‘¼ã³å‡ºã—å…ƒé–¢æ•°ã«ãƒ ãƒ¼ãƒ–ã•ã‚Œã‚‹
}

-----
â—å‚ç…§ã¨å€Ÿç”¨

ãƒ ãƒ¼ãƒ–ã•ã‚Œãªã„ã‚ˆã†ã«ã™ã‚‹ã«ã¯ã€å‚ç…§æ¸¡ã—ã§é–¢æ•°ã«æ¸¡ã™ã€‚
é–¢æ•°ã®å¼•æ•°ã«å‚ç…§ã‚’å–ã‚‹ã“ã¨ã‚’å€Ÿç”¨ã¨å‘¼ã³ã¾ã™ã€‚
å‚ç…§ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ï¼ˆä¸å¤‰ï¼‰ãªã®ã§ã€æ›´æ–°ã¯ã§ããªã„ã€‚

fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);			// &ã‚’ä»˜ã‘ã¦å‚ç…§æ¸¡ã—

    // '{}'ã®é•·ã•ã¯ã€{}ã§ã™
    println!("The length of '{}' is {}.", s1, len);		// ãƒ ãƒ¼ãƒ–ã•ã‚Œã¦ã„ãªã„ã®ã§s1ã¯ä½¿ãˆã‚‹
}

fn calculate_length(s: &String) -> usize {		// é–¢æ•°ã®å¼•æ•°ã«ã‚‚&ã‚’ã¤ã‘ã‚‹ã€‚sã¯Stringã¸ã®å‚ç…§
    s.len()										// å‚ç…§ã§ãã‚‹
    //s.push_str("add");						// ã“ã‚Œã¯ã‚¨ãƒ©ãƒ¼ã€‚æ›´æ–°ã¯ã§ããªã„ã€‚
}												// ã“ã“ã§ã€sã¯ã‚¹ã‚³ãƒ¼ãƒ—å¤–ã«ãªã‚‹ã€‚
												// ã‘ã©ã€å‚ç…§ã—ã¦ã„ã‚‹ã‚‚ã®ã®æ‰€æœ‰æ¨©ã‚’æŒã£ã¦ã„ã‚‹ã‚ã‘ã§ã¯ãªã„ã®ã§
												// ä½•ã‚‚èµ·ã“ã‚‰ãªã„

-----
â—å¯å¤‰å‚ç…§

å‚ç…§ã«ã‚‚mutã‚’ã¤ã‘ã‚Œã°ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ï¼ˆå¯å¤‰ï¼‰ã«ãªã‚‹ã€‚

fn main() {
    let mut s = String::from("hello");	// mutã‚’ã¤ã‘ã¦ãŠã

    change(&mut s);						// &mutã§å¯å¤‰å‚ç…§
}

fn change(some_string: &mut String) {	// é–¢æ•°ã®å¼•æ•°ã«ã‚‚ã¤ã‘ã‚‹
    some_string.push_str(", world");	// æ›´æ–°ã§ãã‚‹
}

â€»æ³¨æ„ç‚¹ï¼šå¯å¤‰å‚ç…§ã¯ã€1ã¤ã—ã‹ä½œã‚Œãªã„ã€‚

let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s;			// ã‚¨ãƒ©ãƒ¼

println!("{}, {}", r1, r2);


ä»¥ä¸‹ã®ã‚ˆã†ã«ã‚¹ã‚³ãƒ¼ãƒ—ãŒåˆ¥ãªã‚‰å°‘ã—ã¯ã¾ã—ã€‚

let mut s = String::from("hello");

{
    let r1 = &mut s;

} // r1ã¯ã“ã“ã§ã‚¹ã‚³ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹ã®ã§ã€å•é¡Œãªãæ–°ã—ã„å‚ç…§ã‚’ä½œã‚‹ã“ã¨ãŒã§ãã‚‹

let r2 = &mut s;



ä¸å¤‰ã¨å¯å¤‰ã®å‚ç…§ã‚‚åŒæ™‚ã«ã¯ä½¿ãˆãªã„ã€‚

let mut s = String::from("hello");

let r1 = &s; // å•é¡Œãªã—
let r2 = &s; // å•é¡Œãªã—
let r3 = &mut s; // å¤§å•é¡Œï¼





-----
â—å‚ç…§å¤–ã—

&ã«ã‚ˆã‚‹å‚ç…§ã®é€†ã€‚*ã‚’ã¤ã‘ã‚‹ã€‚






-----------------------------------------------
â– ã‚¸ã‚§ãƒãƒªãƒƒã‚¯

<T>ã¨ã‹ã€<f32>ã¨ã‹ã«ã¿ãŸã„<>ã§å›²ã‚€ã€‚
Tã¯ã€Tå›ºå®šã§ã¯ãªã„ã€‚ï¼ˆä½•ã§ã‚‚ã‚ˆã„ã€‚_ã§ã‚‚ã‚ˆã„ã€‚ï¼‰

-----------------------------------------------
â– cargo

ãƒ“ãƒ«ãƒ‰ã‚·ã‚¹ãƒ†ãƒ å…¼ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒãƒãƒ¼ã‚¸ãƒ£

-----------------------------------------------
â– å¼ã¨æ–‡

Rustã¯å¼ãƒ™ãƒ¼ã‚¹ã®è¨€èªã€‚
ã»ã¨ã‚“ã©ãŒ å¼ ï¼ˆexpressionï¼‰ã§è¡¨ã•ã‚Œã¾ã™ï¼

ãƒ»å¼
  - ä½•ã‹ã—ã‚‰ã®å€¤ã‚’è¿”ã—ã¾ã™

  ä¾‹.
    6		// æœ€å°ã®å¼
    {}		// ã‚¹ã‚³ãƒ¼ãƒ—ã‚’è¡¨ã™ãƒ–ãƒ­ãƒƒã‚¯ã‚‚å¼
    if		// ifæ–‡ã§ã¯ãªãã€ifå¼
            // ãªã®ã§ã€ä»¥ä¸‹ã‚‚å¯èƒ½ã€‚
            // let a = if true { 5 } else { 3 };

ãƒ»æ–‡
  - ã‚»ãƒŸã‚³ãƒ­ãƒ³ã§çµ‚ç«¯ã•ã‚ŒãŸæ–‡ã¯å¼·åˆ¶çš„ã« () å‹ã¨ãªã‚‹ã€‚
  - å‡¦ç†ã‚’å®Ÿè¡Œã—ã¾ã™ãŒå€¤ã‚’è¿”ã—ã¾ã›ã‚“
  - é–¢æ•°å®šç¾©ã€ãƒã‚¯ãƒ­




-----------------------------------------------
â– ãƒã‚¯ãƒ­

println!
panic!
assert_eq!
format!
vec!


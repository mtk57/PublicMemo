
■VB.NET  Application.DoEventsについて

＜問題点＞   ※参考：http://dotnetrevo.blog21.fc2.com/blog-entry-2.html
    UIスレッド上で、あるボタンのクリックにて、少し時間のかかる処理が呼び出され、定期的にApplication.DoEventsを行うという場合を考えよう。
    DoEventsが呼び出されたとき、どんなことが行われるのだろうか？
    ----------
    ①UIスレッド上での処理はApplication.DoEventsのメソッドの部分で一旦停止する。
    ②ボタンクリックから、①までの間にキューに貯まったWindowsメッセージが処理される。
    ③キューに貯まっていたすべてのWindowsメッセージが処理されたあと、①の続きの処理が実行される。
    ----------
    ここで問題になるのは、②で処理されるWindowsメッセージの内容である。
    ②に含まれているのは、時間のかかる処理が行われる間に、ユーザがほかのボタンを押したり、キーボードを押したイベントの処理がある。
    また、マルチスレッドアプリケーションであれば、UIスレッドへのマーシャリングで待機状態となっていた処理が含まれる。
    ということは、UIスレッド上に割り込ませたいWindowsメッセージ以外のWindowsメッセージが割り込む可能性があるということである。
    割り込んだWindowsメッセージの処理が、ただ進捗状態を表示するだけのようなものであればよいが、
    もしそこから別の時間のかかる処理や、別のスレッドを呼び出すようなものだったらどうだろうか？
    ①の処理を呼び出したユーザの意図とは異なる動作が実行されることになる。
    さらに、もしプログラム上で排他ロックなどを使用していれば、デッドロックが発生することもある。


基本的には使用しないのがベスト


＜代替策＞

Backgroundworkerがいいと思う。


---------------
.net frrameworkの以下のprotectedメソッドについて教えてください
OnCreateControl
OnHandleCreated


はい、.NET Frameworkの`OnCreateControl`と`OnHandleCreated`メソッドについて説明いたします。これらは主にWindows Formsアプリケーションで使用される`Control`クラスのprotectedメソッドです。

1. OnCreateControl:

`OnCreateControl`メソッドは、コントロールが初めて作成されるときに呼び出されます。このメソッドは、コントロールとその子コントロールが作成された後、但しコントロールが表示される前に呼び出されます。

主な特徴:
- コントロールの初期化処理に使用されます。
- 子コントロールの追加や、データバインディングの設定などの初期化タスクに適しています。
- このメソッドはコントロールごとに1回だけ呼び出されます。

使用例:
```csharp
protected override void OnCreateControl()
{
    base.OnCreateControl();
    // カスタムの初期化コードをここに記述
}
```

2. OnHandleCreated:

`OnHandleCreated`メソッドは、コントロールのウィンドウハンドル（HWND）が作成された直後に呼び出されます。

主な特徴:
- ウィンドウハンドルが必要な初期化処理に使用されます。
- ネイティブのWin32 APIを使用する処理に適しています。
- コントロールが破棄されて再作成された場合、このメソッドは複数回呼び出される可能性があります。

使用例:
```csharp
protected override void OnHandleCreated(EventArgs e)
{
    base.OnHandleCreated(e);
    // ウィンドウハンドルを使用する初期化コードをここに記述
}
```

これらのメソッドの主な違いは、`OnCreateControl`がコントロールの論理的な作成時に呼ばれるのに対し、`OnHandleCreated`は実際のウィンドウハンドルが作成された後に呼ばれることです。

適切なメソッドを選択することで、コントロールのライフサイクルの異なる段階で初期化処理を行うことができます。

------------
■動的に他のプログラムのメソッドを実行する方法:
CreateObject()
GetObject()

------------
■VB6 のプロジェクトファイル (.vbp) で使用される設定項目
AutoIncrementVer：ビルド時にバージョン番号を自動的に増加させるかどうか
AutoRefresh：プロジェクトの自動更新を行うかどうか
BoundsCheck：配列の境界チェックを行うかどうか
Class：クラスモジュールの定義
CodeViewDebugInfo：CodeView デバッグ情報を生成するかどうか
Command32：32ビットコマンドラインの設定
CompatibleMode：互換モードの設定
CompilationType：コンパイルの種類（例：ネイティブコード、P-code）
DebugStartupOption：デバッグ時の起動オプション
Designer：デザイナーファイルの指定
ExeName32：32ビット実行ファイルの名前
FDIVCheck：FDIV バグチェックを行うかどうか
FIPointCheck：浮動小数点の整数性チェックを行うかどうか
FavorPentiumPro(tm)：Pentium Pro 最適化を行うかどうか
Form：フォームの定義
HelpContextID：ヘルプコンテキストID
HelpFile：ヘルプファイルの指定
IconForm：アイコンとして使用するフォーム
MajorVer：メジャーバージョン番号
MaxNumberOfThreads：最大スレッド数
MinorVer：マイナーバージョン番号
Module：モジュールの定義
Name：プロジェクト名
NoAliasing：エイリアシングの無効化
Object：オブジェクトの定義
Optimization Type：最適化の種類
OverflowCheck：オーバーフローチェックを行うかどうか
Path32：32ビットパスの指定
Reference：参照設定
RemoveUnusedControlInfo：未使用のコントロール情報を削除するかどうか
Retained：保持されたモジュールの指定
RevisionVer：リビジョンバージョン番号
ServerSupportFiles：サーバーサポートファイルの指定
StartMode：起動モード
Startup：スタートアップオブジェクトの指定
ThreadPerObject：オブジェクトごとのスレッド使用
Title：プロジェクトのタイトル
Type：プロジェクトの種類
Unattended：無人実行モード
UnroundedFP：丸めなし浮動小数点計算の使用
VersionComments：バージョンコメント
VersionCompanyName：会社名
-----------

■構造体のディープコピー


はい、VB.NETで汎用的な構造体のディープコピー関数を作ることができます。主に2つの方法があります：

## 1. シリアライズ/デシリアライズを使用する方法

```vb
Imports System.IO
Imports System.Runtime.Serialization.Formatters.Binary

Public Module DeepCopyHelper
    ''' <summary>
    ''' 任意の型のオブジェクトをディープコピーする
    ''' </summary>
    ''' <typeparam name="T">コピー対象の型</typeparam>
    ''' <param name="source">コピー元オブジェクト</param>
    ''' <returns>ディープコピーされたオブジェクト</returns>
    Public Function DeepCopy(Of T)(ByVal source As T) As T
        ' 元のオブジェクトがNothingの場合
        If source Is Nothing Then
            Return Nothing
        End If
        
        ' シリアライズとデシリアライズを使用してディープコピー
        Dim formatter As New BinaryFormatter()
        Dim stream As New MemoryStream()
        
        ' ストリームにシリアライズ
        formatter.Serialize(stream, source)
        
        ' ストリームの位置を先頭に戻す
        stream.Position = 0
        
        ' デシリアライズして新しいオブジェクトを作成
        Dim result As T = DirectCast(formatter.Deserialize(stream), T)
        
        ' ストリームを閉じる
        stream.Close()
        
        Return result
    End Function
End Module
```

この方法を使用する場合の注意点：
- コピー対象の型に `<Serializable()>` 属性が必要です
- シリアライズできないメンバー（例：デリゲート、イベントハンドラなど）があると失敗します

## 2. リフレクションを使用する方法

```vb
Imports System.Reflection

Public Module DeepCopyHelper
    ''' <summary>
    ''' リフレクションを使用して構造体をディープコピーする
    ''' </summary>
    ''' <typeparam name="T">コピー対象の型</typeparam>
    ''' <param name="source">コピー元オブジェクト</param>
    ''' <returns>ディープコピーされたオブジェクト</returns>
    Public Function DeepCopyStructure(Of T As Structure)(ByVal source As T) As T
        ' 結果の変数を作成
        Dim result As T = source
        
        ' 型の情報を取得
        Dim type As Type = GetType(T)
        
        ' すべてのフィールド情報を取得
        Dim fields As FieldInfo() = type.GetFields(BindingFlags.Public Or BindingFlags.NonPublic Or BindingFlags.Instance)
        
        For Each field As FieldInfo In fields
            ' フィールドの値を取得
            Dim value As Object = field.GetValue(source)
            
            ' 値がNothingでなく配列の場合
            If value IsNot Nothing AndAlso value.GetType().IsArray Then
                ' 配列をコピー
                Dim array As Array = DirectCast(value, Array)
                Dim copyArray As Array = Array.CreateInstance(array.GetType().GetElementType(), array.Length)
                Array.Copy(array, copyArray, array.Length)
                
                ' コピーした配列を設定
                field.SetValue(result, copyArray)
            End If
        Next
        
        Return result
    End Function
End Module
```

## 使用例

```vb
' 構造体の定義
<Serializable()> _
Public Structure StructureB
    Public Value As Integer
End Structure

<Serializable()> _
Public Structure StructureA
    Public ID As Integer
    Public Name As String
    Public stBary() As StructureB
End Structure

' 使用例
Sub Main()
    ' 元の構造体を作成
    Dim stA1 As StructureA
    stA1.ID = 1
    stA1.Name = "Test"
    stA1.stBary = New StructureB(1) {}
    stA1.stBary(0).Value = 10
    
    ' ディープコピー
    Dim stA2 As StructureA = DeepCopy(stA1)
    
    ' 値を変更してみる
    stA2.stBary(0).Value = 20
    
    ' 結果を確認
    Console.WriteLine($"stA1.stBary(0).Value = {stA1.stBary(0).Value}")  ' 10
    Console.WriteLine($"stA2.stBary(0).Value = {stA2.stBary(0).Value}")  ' 20
End Sub
```

シリアライズ方式は汎用性が高く、ほとんどの場合に適しています。ただし、パフォーマンスが重要な場合やシリアライズできないメンバーがある場合は、リフレクション方式または構造体固有のディープコピー方法を検討すると良いでしょう。


-------------
はい、ご質問の件について説明します。

VB.NETでは、構造体（Structure）は値型（Value Type）ですが、配列は参照型（Reference Type）です。そのため：

1. 構造体A型の変数stA1を構造体A型の変数stA2に代入すると、構造体自体は値コピーされますが、配列メンバであるstBaryは参照コピーされます。つまり、stA2.stBaryとstA1.stBaryは同じ配列オブジェクトを参照します。

2. はい、stA2.stBaryの値（配列の要素）を変更すると、stA1.stBaryの値も変更されます。これは両方が同じメモリ上の配列を参照しているためです。

もし配列の完全なコピー（ディープコピー）が必要な場合は、明示的に新しい配列を作成し、要素をコピーする必要があります。例えば：

```vb
' ディープコピーの例
stA2 = stA1
Dim newArray(stA1.stBary.Length - 1) As StructureB
Array.Copy(stA1.stBary, newArray, stA1.stBary.Length)
stA2.stBary = newArray
```

このようにすれば、stA2.stBaryに加えた変更はstA1.stBaryに影響しません。




